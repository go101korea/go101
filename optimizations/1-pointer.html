<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Pointers -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Pointers</h1>



<h2>Avoid unnecessary nil array pointer checks in a loop</h2>

<p>There are some flaws in the current official standard Go compiler implementation (v1.20).
One of them is <a href="https://github.com/golang/go/issues/41666">some nil array pointer checks are not moved out of loops</a>.
Here is an example to show this flaw.</p>

<pre><code class="language-Go">// unnecessary-checks.go
package pointers

import &quot;testing&quot;

const N = 1000
var a [N]int

//go:noinline
func g0(a *[N]int) {
	for i := range a {
		a[i] = i // line 12
	}
}

//go:noinline
func g1(a *[N]int) {
	_ = *a // line 18
	for i := range a {
		a[i] = i // line 20
	}
}

func Benchmark_g0(b *testing.B) {
	for i := 0; i &lt; b.N; i++ { g0(&amp;a) }
}

func Benchmark_g1(b *testing.B) {
	for i := 0; i &lt; b.N; i++ { g1(&amp;a) }
}
</code></pre>

<p>Let's run the benchmarks with the <code>-S</code> compiler option, the following outputs are got (uninterested texts are omitted):</p>

<pre><code>$ go test -bench=. -gcflags=-S unnecessary-checks.go
...
0x0004 00004 (unnecessary-checks.go:12)	TESTB	AL, (AX)
0x0006 00006 (unnecessary-checks.go:12)	MOVQ	CX, (AX)(CX*8)
...
0x0000 00000 (unnecessary-checks.go:18)	TESTB	AL, (AX)
0x0002 00002 (unnecessary-checks.go:18)	XORL	CX, CX
0x0004 00004 (unnecessary-checks.go:19)	JMP	13
0x0006 00006 (unnecessary-checks.go:20)	MOVQ	CX, (AX)(CX*8)
...
Benchmark_g0-4  517.6 ns/op
Benchmark_g1-4  398.1 ns/op
</code></pre>

<p>From the outputs, we could find that the <code>g1</code> implementation is more performant than the <code>g0</code> implementation,
even if the <code>g1</code> implementation contains one more code line (line 18).
Why? The question is answered by the outputted assembly instructions.</p>

<p>In the <code>g0</code> implementation, the <code>TESTB</code> instruction is generated within the loop, whereas in the <code>g1</code> implementation, the <code>TESTB</code> instruction is generated out of the loop.
The <code>TESTB</code> instruction is used to check whether or not the argument <code>a</code> is a nil pointer.
For this specified case, checking once is enough.
The one more code line avoids the flaw in the compiler implementation.</p>

<p>There is a third implementation which is as performant as the <code>g1</code> implementation.
The third implementation uses a slice derived from the array pointer argument.</p>

<pre><code class="language-Go">//go:noinline
func g2(x *[N]int) {
	a := x[:]
	for i := range a {
		a[i] = i
	}
}
</code></pre>

<p>Please note that the flaw might be fixed in future compiler versions.</p>

<p>And please note that, if the three implementation functions are inline-able, the benchmark results will change much.
That is the reason why the <code>//go:noinline</code> compiler directives are used here.
(Before Go toolchain v1.18, the <code>//go:noinline</code> compiler directives are actually unnecessary here.
Because Go toolchain v1.18- never inlines a function containing a <code>for-range</code> loop.)</p>

<h3>The case in which an array pointer is a struct field</h3>

<p>For the cases in which an array pointer is a struct field, things are a little complex.
The <code>_ = *t.a</code> line in the following code is useless to avoid the compiler flaw.
For example, in the following code, the performance difference between the <code>f1</code> function and the <code>f0</code> function is small.
(In fact, the <code>f1</code> function might be even slower, if a <code>NOP</code> instruction is generated within its loop.)</p>

<pre><code class="language-Go">type T struct {
	a *[N]int
}

//go:noinline
func f0(t *T) {
	for i := range t.a {
		t.a[i] = i
	}
}

//go:noinline
func f1(t *T) {
	_ = *t.a
	for i := range t.a {
		t.a[i] = i
	}
}
</code></pre>

<p>To move the nil array pointer checks out of the loop, we should copy the <code>t.a</code> field to a local variable, then adopt the trick introduced above:</p>

<pre><code class="language-Go">//go:noinline
func f3(t *T) {
	a := t.a
	_ = *a
	for i := range a {
		a[i] = i
	}
}
</code></pre>

<p>Or simply derive a slice from the array pointer field:</p>

<pre><code class="language-Go">//go:noinline
func f4(t *T) {
	a := t.a[:]
	for i := range a {
		a[i] = i
	}
}
</code></pre>

<p>The benchmark results:</p>

<pre><code>Benchmark_f0-4  622.9 ns/op
Benchmark_f1-4  637.4 ns/op
Benchmark_f2-4  511.3 ns/op
Benchmark_f3-4  390.1 ns/op
Benchmark_f4-4  387.6 ns/op
</code></pre>

<p>The results verify our previous conclusions.</p>

<p>Note, the <code>f2</code> function mentioned in the benchmark results is declared as</p>

<pre><code class="language-Go">//go:noinline
func f2(t *T) {
	a := t.a
	for i := range a {
		a[i] = i
	}
}
</code></pre>

<p>The <code>f2</code> implementation is not fast as the <code>f3</code> and <code>f4</code> implementations, but it is faster than the <code>f0</code> and <code>f1</code> implementations. However, that is <a href="2-struct.html#avoid-accessing-fields-in-loops">another story</a>.</p>

<p>If the elements of an array pointer field are not modified (only read) in the loop, then the <code>f1</code> way is as performant as the <code>f3</code> and <code>f4</code> way.</p>

<p>Personally, for most cases, I think we should try to use the slice way (the <code>f4</code> way) to get the best performance,
because generally slices are optimized better than arrays by the official standard Go compiler.</p>

<h2 id="avoid-unnecessary-dereferences">Avoid unnecessary pointer dereferences in a loop</h2>

<p>Sometimes, the current official standard Go compiler (v1.20) is <a href="https://github.com/golang/go/issues/49785">not smart enough to generate assembly instructions in the most optimized way</a>. We have to write the code in another way to get the best performance. For example, in the following code, the <code>f</code> function is much less performant than the <code>g</code> function.</p>

<pre><code class="language-Go">// avoid-indirects_test.go
package pointers

import &quot;testing&quot;

//go:noinline
func f(sum *int, s []int) {
	for _, v := range s { // line 8
		*sum += v // line 9
	}
}

//go:noinline
func g(sum *int, s []int) {
	var n = *sum
	for _, v := range s { // line 16
		n += v // line 17
	}
	*sum = n
}

var s = make([]int, 1024)
var r int

func Benchmark_f(b *testing.B) {
	for i := 0; i &lt; b.N; i++ {
		f(&amp;r, s)
	}
}

func Benchmark_g(b *testing.B) {
	for i := 0; i &lt; b.N; i++ {
		g(&amp;r, s)
	}
}
</code></pre>

<p>The benchmark results (uninterested texts are omitted):</p>

<pre><code>$ go test -bench=. -gcflags=-S avoid-indirects_test.go
...
0x0009 00009 (avoid-indirects_test.go:9)	MOVQ	(AX), SI
0x000c 00012 (avoid-indirects_test.go:9)	ADDQ	(BX)(DX*8), SI
0x0010 00016 (avoid-indirects_test.go:9)	MOVQ	SI, (AX)
0x0013 00019 (avoid-indirects_test.go:8)	INCQ	DX
0x0016 00022 (avoid-indirects_test.go:8)	CMPQ	CX, DX
0x0019 00025 (avoid-indirects_test.go:8)	JGT	9
...
0x000b 00011 (avoid-indirects_test.go:16)	MOVQ	(BX)(DX*8), DI
0x000f 00015 (avoid-indirects_test.go:16)	INCQ	DX
0x0012 00018 (avoid-indirects_test.go:17)	ADDQ	DI, SI
0x0015 00021 (avoid-indirects_test.go:16)	CMPQ	CX, DX
0x0018 00024 (avoid-indirects_test.go:16)	JGT	11
...
Benchmark_f-4  3024 ns/op
Benchmark_g-4   566.6 ns/op
</code></pre>

<p>The outputted assembly instructions show the pointer <code>sum</code> is dereferenced within the loop in the <code>f</code> function.
A dereference operation is a memory operation.
For the <code>g</code> function, the dereference operations happen out of the loop,
and the instructions generated for the loop only process registers.
It is much faster to let CPU instructions process registers than process memory,
which is why the <code>g</code> function is much more performant than the <code>f</code> function.</p>

<p>This is not a compiler flaw. In fact, the <code>f</code> and <code>g</code> functions are not equivalent
(though for most use cases in practice, their results are the same).
For example, if they are called like the following code shows, then they return different results
(thanks to skeeto@reddit for <a href="https://old.reddit.com/r/golang/comments/uy7weh/use_go_pointer_efficiently_in_some_cases/ia39qwk/">making this correction</a>).</p>

<pre><code class="language-Go">{
	var s = []int{1, 1, 1}
	var sum = &amp;s[2]
	f(sum, s)
	println(*sum) // 6
}
{
	var s = []int{1, 1, 1}
	var sum = &amp;s[2]
	g(sum, s)
	println(*sum) // 4
}
</code></pre>

<p>Another performant implementation for this specified case is to move the pointer parameter out of the function body
(again, it is not totally equivalent to either <code>f</code> or <code>g</code> function):</p>

<pre><code class="language-Go">//go:noinline
func h(s []int) int {
	var n = 0
	for _, v := range s {
		n += v
	}
	return n
}

func use_h(s []int) {
	var sum = new(int)
	*sum += h(s)
	...
}
</code></pre>
<hr>

<div class="text-center"><a href="#i-1-pointer.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go-optimizations-101">Leanpub</a>,
	<i>최소 7.99 달러</i> (<a href="https://leanpub.com/b/go-optimizations-details-generics">이곳</a>이나 <a href="https://leanpub.com/b/go-optimizations-details">이곳</a>에서 번들로 구매하세요).
</li>
<li>
	<a href="https://books.apple.com/book/id1609924340">애플 북스</a>,
	<i>7.99 달러</i>.
</li>
<li>
	<a href="https://www.amazon.com/dp/B09NT2HJCM">아마존 킨들 스토어</a>,
	<i>7.99 달러</i>.
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">
	
<ul class="index part">
	<li><a class="index" href="0.0-acknowledgements.html">Acknowledgments</a></li>
	<li><a class="index" href="0.1-introduction.html">About Go Optimizations 101</a></li>
	<li>Value Parts and Value Sizes <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>value/type sizes</li>
		<li>memory alignments</li>
		<li>struct padding</li>
		<li>avoid larger copy costs</li>
	</ul>
	<li><a class="index" href="0.3-memory-allocations.html">Memory Allocations</a></li>
	<li>Stack and Escape Analysis <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>escape analysis</li>
		<li>how to control value allocation places</li>
		<li>stacks growth and shrinkage</li>
		<li>how to reduce stack grow times</li>
	</ul>
	<li>Garbage Collection <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>GC pacer</li>
		<li>how to reduce GC pressure</li>
		<li>control GC frequency</li>
	</ul>
	<li><b class="index" id="i-1-pointer.html">Pointers</b></li>
	<li>Structs <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>3 facts/suggestions</li>
	</ul>
	<li>Arrays and Slices <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>10+ facts/suggestions</li>
	</ul>
	<li>String and Byte Slices <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>10+ facts/suggestions</li>
	</ul>
	<li>BCE (Bound Check Eliminate) <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>the cases BCE works for</li>
		<li>the cases BCE doesn't work for</li>
		<li>the cases BCE works for when given hints</li>
	</ul>
	<li><a class="index" href="6-map.html">Maps</a></li>
	<li>Channels <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>3 facts/suggestions</li>
	</ul>
	<li>Functions <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>how to make a function inline-able</li>
		<li>how to make a function not inline-able</li>
		<li>pointer parameters/results vs. non-pointer ones</li>
		<li>named results vs. anonymous ones</li>
		<li>10+ facts/suggestions</li>
	</ul>
	<li>Interfaces <sup><small>(available in <a href="#ebooks">the paid ebooks</a>)</small></sup></li>
	<ul>
		<li>value boxing costs</li>
		<li>3+ facts/suggestions</li>
	</ul>
</ul>


</div>








		</div>
	</body>
</html>












