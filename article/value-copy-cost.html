<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Go Value Copy Costs -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Go Value Copy Costs</h1>



<p>
Value copying happens frequently in Go programming.
Values assignments, argument passing and channel value send operations
are all value copying involved.
This article will talk about the copy costs of values of all kinds of types.
</p>

<a class="anchor" id="value-sizes"></a>
<h3>Value Sizes</h3>

<p>
The size of a value means how many bytes the
<a href="value-part.html">direct part</a> of the value will occupy in memory.
The indirect underlying parts of a value don't contribute to the size of the value.
</p>

<p>
In Go, if the types of two values belong to the same
<a href="type-system-overview.html#type-kinds">kind</a>,
and the type kind is not string kind,
interface kind, array kind and struct kind,
then the sizes of the two value are always equal.
</p>

<p>
In fact, for the standard Go compiler/runtime,
the sizes of two string values are also always equal.
The same relation is for the sizes of two interface values.
</p>

<p>
Up to present (Go Toolchain 1.20), for the standard Go compiler (and gccgo),
values of a specified type always have the same value size.
So, often, we call the size of a value as the size of the type of the value.
</p>

<p>
The size of an array type depends on the element type size and the length
of the array type. The array type size is the product of the size of
the array element type and the array length.
</p>

<p>
The size of a struct type depends on all of the sizes and the order of its fields.
For there may be some <a href="memory-layout.html#size-and-padding">padding bytes</a> being inserted
between two adjacent struct fields to guarantee certain memory address alignment requirements of these fields,
so the size of a struct type must be not smaller than (and often larger than) the sum of the respective type sizes
of its fields.
</p>

<p>
The following table lists the value sizes of all kinds of types
(for the standard Go compiler version 1.20).
In the table, one word means one native word,
which is 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures.
</p>

<table border="1" class="table table-bordered text-center" style="width: auto !important;">
	<thead>
		<tr>
			<th class="text-center" valign="bottom" align="center">Kinds of Types</th>
			<th class="text-center" valign="bottom" align="center">Value Size</th>
			<th class="text-center" valign="bottom" align="center">
				<a href="https://golang.org/ref/spec#Size_and_alignment_guarantees">Required</a>
				by <a href="https://golang.org/ref/spec#Numeric_types">Go Specification</a>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">bool</th>
			<td valign="middle" align="center">1 byte</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">int8, uint8 (byte)</th>
			<td valign="middle" align="center">1 byte</td>
			<td valign="middle" align="center">1 byte</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">int16, uint16</th>
			<td valign="middle" align="center">2 bytes</td>
			<td valign="middle" align="center">2 bytes</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">int32 (rune), uint32, float32</th>
			<td valign="middle" align="center">4 bytes</td>
			<td valign="middle" align="center">4 bytes</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">int64, uint64, float64, complex64
			</th>
			<td valign="middle" align="center">8 bytes</td>
			<td valign="middle" align="center">8 bytes</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">complex128</th>
			<td valign="middle" align="center">16 bytes</td>
			<td valign="middle" align="center">16 bytes</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">int, uint</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">architecture dependent, 4 bytes on 32-bit architectures and 8 bytes
				on 64-bit architectures</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">uintptr</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">large enough to store the uninterpreted bits of a pointer value
			</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">string</th>
			<td valign="middle" align="center">2 words</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">pointer (safe or unsafe)</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">slice</th>
			<td valign="middle" align="center">3 words</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">map</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">channel</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">function</th>
			<td valign="middle" align="center">1 word</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr>
			<th scope="row" class="text-center" valign="middle" align="center">interface</th>
			<td valign="middle" align="center">2 words</td>
			<td valign="middle" align="center">not specified</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">struct</th>
			<td valign="middle" align="center">(the sum of sizes of all fields) + (the number of
				<a href="memory-layout.html#size-and-padding">padding</a> bytes)
			</td>
			<td valign="middle" align="center">the size of a <b>struct</b> type is zero if it contains no fields
				that have a size greater than zero</td>
		</tr>
		<tr class="active">
			<th scope="row" class="text-center" valign="middle" align="center">array</th>
			<td valign="middle" align="center">(element value size) * (array length)</td>
			<td valign="middle" align="center">the size of an <b>array</b> type is zero if its element type
				has zero size</td>
		</tr>
	</tbody>
</table>

<a class="anchor" id="copy-costs"></a>
<h3>Value Copy Costs</h3>

<div>
<p>
Generally speaking, the cost to copy a value is proportional to the size of the value.
However, value sizes are not the only factor determining value copy costs.
Different CPU models and compiler versions may specially optimize value copying for values with specific sizes.
</p>

<p>
In practice, we can view struct values with less than 5 fields and with sizes not larger than
four native words as small-size values. The costs of copying small-size values are small.
</p>

<p>
For the standard Go compiler,
except values of large-size struct and array types,
other types in Go are all small-size types.
</p>

<p>
To avoid large value copy costs in argument passing and channel value send
and receive operations, we should try to avoid using large-size
struct and array types as function and method parameter types
(including method receiver types) and channel element types.
We can use pointer types whose base types are large-size types instead for such scenarios.
</p>

<p>
One the other hand, we should also consider the fact that too many pointers
will increase the pressure of garbage collectors at run time.
So whether large-size struct and array types or their corresponding pointer
types should be used relies on specific circumstances.
</p>

<p>
Generally, in practice, we seldom use pointer types whose base types are
slice types, map types, channel types, function types, string types and interface types.
The costs of copying values of these assumed base types are very small.
</p>

<p>
We should also try to avoid using the two-iteration-variable forms to
iterate array and slice elements if the element types are large-size types,
for each element value will be copied to the second iteration variable
in the iteration process.
</p>

The following is an example which benchmarks different ways to iterate slice elements.

<pre class="line-numbers"><code class="language-go">package main

import "testing"

type S [12]int64
var sX = make([]S, 1000)
var sY = make([]S, 1000)
var sZ = make([]S, 1000)
var sumX, sumY, sumZ int64

func Benchmark_Loop(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sumX = 0
		for j := 0; j < len(sX); j++ {
			sumX += sX[j][0]
		}
	}
}

func Benchmark_Range_OneIterVar(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sumY = 0
		for j := range sY {
			sumY += sY[j][0]
		}
	}
}

func Benchmark_Range_TwoIterVar(b *testing.B) {
	for i := 0; i < b.N; i++ {
		sumZ = 0
		for _, v := range sZ {
			sumZ += v[0]
		}
	}
}
</code></pre>

Run the benchmarks in the directory of the test file,
we will get a result similar to:

<pre class="output"><code>Benchmark_Loop-4             424342 2708 ns/op
Benchmark_Range_OneIterVar-4 407905 2808 ns/op
Benchmark_Range_TwoIterVar-4 214860 5222 ns/op
</code></pre>

<p>
We can find that the efficiency of the two-iteration-variable form is much
lower than the other two.
But please note that, some compilers might make special optimizations
to remove the performance differences between these forms.
The above benchmark result is for the standard Go compiler version 1.20.
</p>

</div>
<hr>

<div class="text-center"><a href="#i-value-copy-cost.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><b class="index" id="i-value-copy-cost.html">Go의 값 복사 비용</b></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












