<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Memory Blocks -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Memory Blocks</h1>



<p>
Go is a language which supports automatic memory management,
such as automatic memory allocation and automatic garbage collection.
So Go programmers can do programming without handling the underlying verbose memory management.
This not only brings much convenience and saves Go programmers lots of time,
but also helps Go programmers avoid many careless bugs.
</p>

<p>
Although knowing the underlying memory management implementation details is not necessary
for Go programmers to write Go code, understanding some concepts and being aware of some facts
in the memory management implementation by the standard Go compiler and runtime is very
helpful for Go programmers to write high quality Go code.
</p>

<p>
This article will explain some concepts and list some facts of the implementation of
memory block allocation and garbage collection by the standard Go compiler and runtime.
Other aspects, such as memory apply and memory release in memory management,
will not be touched in this article.
</p>

<a class="anchor" id="memory-block"></a>
<h3>Memory Blocks</h3>

<p>
A memory block is a continuous memory segment to host
<a href="value-part.html">value parts</a> at run time.
Different memory blocks may have different sizes, to host different value parts.
One memory block may host multiple value parts at the same time,
but each value part can only be hosted within one memory block,
no matter how large the size of that value part is.
In other words, for any value part, it never crosses memory blocks.
</p>

<div>
There are many reasons when one memory block may host multiple value parts. Some of them:
<ul>
<li>
	a struct value often have several fields. So when a memory block is allocated for
	a struct value, the memory block will also host (the direct parts of) these field values.
</li>
<li>
	an array values often have many elements. So when a memory block is allocated for
	a array value, the memory block will also host (the direct parts of) the array element values.
</li>
<li>
	the underlying element sequences of two slices may be hosted on the same memory block,
	the two element sequences even can overlap with each other.
</li>
</ul>
</div>

<h3>A Value References the Memory Blocks Which Host Its Value Parts</h3>

<p>
We have known that a value part can reference another value part.
Here, we extend the reference definition by saying
a memory block is referenced by all the value parts it hosts.
So if a value part <code>v</code> is referenced by another value part,
then the other value will also reference the memory block hosting <code>v</code>, indirectly.
</p>

<a class="anchor" id="when-to-allocate"></a>
<h3>When Will Memory Blocks Be Allocated?</h3>

<div>
In Go, memory blocks may be allocated but not limited at following situations:
<ul>
<li>
	explicitly call the <code>new</code> and <code>make</code> built-in functions.
	A <code>new</code> call will always allocate exact one memory block.
	A <code>make</code> call will allocate more than one memory blocks to host
	the direct part and underlying part(s) of the created slice, map or channel value.
</li>
<li>
	create maps, slices and anonymous functions with corresponding literals.
	More than one memory blocks may be allocated in each of the processes.
</li>
<li>
	declare variables.
</li>
<li>
	assign non-interface values to interface values
	(when the non-interface value is not a pointer value).
</li>
<li>
	concatenate non-constant strings.
</li>
<li>
	convert strings to byte or rune slices, and vice versa,
	except <a href="string.html#conversion-optimizations">some special compiler optimization cases</a>.
</li>
<li>
	convert integers to strings.
</li>
<li>
	call the built-in <code>append</code> function (when the capacity of the base slice is not large enough).
</li>
<li>
	add a new key-element entry pair into a map (when the underlying hash table needs to be resized).
</li>
</ul>

</div>

<a class="anchor" id="where-to-allocate"></a>
<h3>Where Will Memory Blocks Be Allocated On?</h3>

<p>
For every Go program compiled by the official standard Go compiler, at run time,
each goroutine will maintain a stack, which is a memory segment.
It acts as a memory pool for some memory blocks to be allocated from/on.
Before Go Toolchain 1.19, the initial size of a stack is always 2KiB.
Since Go Toolchain 1.19, the initial size is <a href="https://docs.google.com/document/d/1YDlGIdVTPnmUiTAavlZxBI1d9pwGQgZT7IKFKlIXohQ">adaptive</a>.
The stack of a goroutine will grow and shrink as needed in goroutine running.
The minimum stack size is 2KiB.
</p>

<p><i>
(Please note, there is a global limit of stack size each goroutine may reach.
If a goroutine exceeds the limit while growing its stack, the program crashes.
As of Go Toolchain 1.20, the default maximum stack size
is 1 GB on 64-bit systems, and 250 MB on 32-bit systems.
We can call the <code>SetMaxStack</code> function in the
<code>runtime/debug</code> standard package to change the size.
And please note that, by the current official standard Go compiler implementation,
the actual allowed maximum stack size is the largest power of 2
which is not larger than then MaxStack setting.
So for the default setting, the actual allowed maximum stack size is 512 MiB
on 64-bit systems, and 128 MiB on 32-bit systems.)
</i></p>

<p>
Memory blocks can be allocated on stacks.
Memory blocks allocated on the stack of a goroutine can only be used (referenced)
in the goroutine internally.
They are goroutine localized resources.
They are not safe to be referenced crossing goroutines.
A goroutine can access or modify the value parts hosted on a memory block
allocated on the stack of the goroutine
without using any data synchronization techniques.
</p>

<p>
Heap is a singleton in each program. It is a virtual concept.
If a memory block is not allocated on any goroutine stack,
then we say the memory block is allocated on heap.
Value parts hosted on memory blocks allocated on heap
can be used by multiple goroutines.
In other words, they can be used concurrently.
Their uses should be synchronized when needed.
</p>

<p>
Heap is a conservative place to allocate memory blocks on.
If compilers detect a memory block will be referenced crossing goroutines
or can't easily confirm whether or not the memory block is safe to be put on the stack of a goroutine,
then the memory block will be allocated on heap at run time.
This means some values which can be safely allocated on stacks may also be allocated on heap.
</p>

<!--
For the standard Go compiler,
https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/preview

very large memory blocks will always be allocated on heap?
https://github.com/golang/go/issues/20021

The values referenced by values allocated on heap will never be allocated in stacks.
-->

<div>
In fact, stacks are not essential for Go programs.
Go compiler/runtime can allocate all memory block on heap.
Supporting stacks is just to make Go programs run more efficiently:
<ul>
<li>
	allocating memory blocks on stacks is much faster than on heap.
</li>
<li>
	memory blocks allocated on a stack don't need to be garbage collected.
</li>
<li>
	stack memory blocks are more CPU cache friendly than heap ones.
</li>
</ul>
</div>

<p>
If a memory block is allocated somewhere, we can also say the value parts hosted
on the memory block are allocated on the same place.
</p>

<p>
If some value parts of a local variable declared in a function is allocated on heap,
we can say the value parts (and the variable) escape to heap.
By using Go Toolchain, we can run <code>go build -gcflags -m</code> to check
which local values (value parts) will escape to heap at run time.
As mentioned above, the current escape analyzer in the standard Go compiler
is still not perfect, many local value parts can be allocated on stacks safely
will still escape to heap.
</p>

<p>
An active value part allocated on heap still in use must be referenced by at least one value part allocated on a stack.
If a value escaping to heap is a declared local variable, and assume its type is <code>T</code>,
Go runtime will create (a memory block for)
an implicit pointer of type <code>*T</code> on the stack of the current goroutine.
The value of the pointer stores the address of the memory block allocated for the variable on heap
(a.k.a., the address of the local variable of type <code>T</code>).
Go compiler will also replace all uses of the variable with
dereferences of the pointer value at compile time.
The <code>*T</code> pointer value on stack may be marked as dead since a later time,
so the reference relation from it to the <code>T</code> value on heap will disappear.
The reference relation from the <code>*T</code> value on stack to the <code>T</code> value on heap
plays an important role in the garbage collection process which will be described below.
</p>

<p>
Similarly, we can view each package-level variable is allocated on heap,
and the variable is referenced by an implicit pointer which is allocated on a global memory zone.
In fact, the implicit pointer references the direct part of the package-level variable,
and the direct part of the variable references some other value parts.
</p>

<p>
A memory block allocated on heap may be referenced by multiple value parts allocated on different stacks at the same time.
</p>

<div>
Some facts:
<ul>
<li>
	if a field of a struct value escapes to heap,
	then the whole struct value will also escape to heap.
</li>
<li>
	if an element of an array value escapes to heap,
	then the whole array value will also escape to heap.
</li>
<li>
	if an element of a slice value escapes to heap,
	then all the elements of the slice will also escape to heap.
</li>
<li>
	if a value (part) <code>v</code> is referenced by a value (part) which escapes to heap,
	then the value (part) <code>v</code> will also escape to heap.
</li>
</ul>
</div>

<p>
A memory block created by calling <code>new</code> function may be allocated on heap or stacks.
This is different to C++.
</p>

When the size of a goroutine stack changes (for stack growth or shrinkage),
a new memory segment will be allocated for the stack.
So the memory blocks allocated on the stack will very likely be moved, or their addresses will change.
Consequently, the pointers, which must be also allocated on the stack,
referencing these memory blocks also need to be modified accordingly.
The following is such an example.

<pre class="line-numbers"><code class="language-go">package main

// The following directive is to prevent
// calls to the function f being inlined.
//go:noinline
func f(i int) byte {
	var a [1<<20]byte // make stack grow
	return a[i]
}

func main(){
	var x int
	println(&x)
	f(100)
	println(&x)
}
</code></pre>

<p>
We will find that the two printed addresses are different (as of the standard Go compiler v1.20).
</p>

<!--p>
Another important fact we should know is,
to make 64-bit word atomic operations possible on 32-bit architectures,
the address of any memory block allocated on heap is guaranteed to be 8-byte aligned.
</p-->

<a class="anchor" id="when-can-collect"></a>
<h3>When Can a Memory Block Be Collected?</h3>

<p>
Memory blocks allocated for direct parts of package-level variables will never be collected.
</p>

<p>
The stack of a goroutine will be collected as a whole when the goroutine exits.
So there is no need to collect the memory blocks allocated on stacks, individually, one by one.
Stacks are not collected by the garbage collector.
</p>

<p>
For a memory block allocated on heap, it can be safely collected only if
it is no longer referenced (either directly or indirectly)
by all the value parts allocated on goroutine stacks and the global memory zone.
We call such memory blocks as unused memory blocks.
Unused memory blocks on heap will be collected by the garbage collector.
</p>

<div>
Here is an example to show when some memory blocks can be collected:
<pre class="line-numbers"><code class="language-go">package main

var p *int

func main() {
	done := make(chan bool)
	// "done" will be used in main and the following
	// new goroutine, so it will be allocated on heap.

	go func() {
		x, y, z := 123, 456, 789
		_ = z  // z can be allocated on stack safely.
		p = &x // For x and y are both ever referenced
		p = &y // by the global p, so they will be both
		       // allocated on heap.

		// Now, x is not referenced by anyone, so
		// its memory block can be collected now.

		p = nil
		// Now, y is also not referenced by anyone,
		// so its memory block can be collected now.

		done <- true
	}()

	<-done
	// Now the above goroutine exits, the done channel
	// is not used any more, a smart compiler may
	// think it can be collected now.

	// ...
}
</code></pre>

<p>
</p>

Sometimes, smart compilers, such as the standard Go compiler,
may make some optimizations so that some references
are removed earlier than we expect. Here is such an example.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	// Assume the length of the slice is so large
	// that its elements must be allocated on heap.
	bs := make([]byte, 1 << 31)

	// A smart compiler can detect that the
	// underlying part of the slice bs will never be
	// used later, so that the underlying part of the
	// slice bs can be garbage collected safely now.

	fmt.Println(len(bs))
}
</code></pre>

<p>
Please read <a href="value-part.html">value parts</a> to learn the
internal structures of slice values.
</p>

<p>
By the way, sometimes, we may hope the slice <code>bs</code> is guaranteed
to not being garbage collected until <code>fmt.Println</code> is called,
then we can use a <code>runtime.KeepAlive</code> function call to tell
garbage collectors that the slice <code>bs</code> and
the value parts referenced by it are still in use.
</p>

For example,

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "runtime"

func main() {
	bs := make([]int, 1000000)

	fmt.Println(len(bs))

	// A runtime.KeepAlive(bs) call is also
	// okay for this specified example.
	runtime.KeepAlive(&bs)
}
</code></pre>

<p>
</p>

</div>

<a class="anchor" id="how-to-detect"></a>
<h3>How Are Unused Memory Blocks Detected?</h3>

<div>
<p>
The current standard Go compiler (version 1.20) uses
a concurrent, tri-color, mark-sweep garbage collector.
Here this article will only make a simple explanation for the algorithm.
</p>

<p>
A garbage collection (GC) process is divided into two phases, the mark phase and the sweep phase.
In the mark phase, the collector (a group of goroutines actually) uses the tri-color algorithm to analyze
which memory blocks are unused.
</p>

The following quote is taken from <a href="https://blog.golang.org/go15gc">a Go blog article</a>
and is modified a bit to make it clearer.

<blockquote style="margin-top:0px;margin-bottom:0px;">
<small>
	At the start of a GC cycle all heap memory blocks are white.
	The GC visits all roots, which are objects directly accessible by the application
	such as globals and things on the stack, and colors these grey.
	The GC then chooses a grey object, blackens it, and then scans it for pointers to other objects.
	When this scan finds a pointer to a white memory block, it turns that object grey.
	This process repeats until there are no more grey objects.
	At this point, white (heap) memory blocks are known to be unreachable and can be reused.
</small>
</blockquote>


<p><i>
(About why the algorithm uses three colors instead of two colors, please search "write barrier golang" for details.
Here only provides two references: <a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">eliminate STW stack re-scanning</a> and <a href="https://golang.org/src/runtime/mbarrier.go">mbarrier.go</a>.)
</i></p>

<p>
In the sweep phase, the marked unused memory blocks will be collected.
</p>

<p>
An unused memory block may not be released to OS immediately after it is collected,
so that it can be reused for new some value parts.
Don't worry, the official Go runtime is much less memory greedy than most Java runtimes.
</p>

<p>
The GC algorithm is a non-compacting one, so it will not move memory blocks to rearrange them.
</p>


</div>

<a class="anchor" id="when-to-collect"></a>
<h3>When Will a New Garbage Collection Process Start?</h3>

<div>

<p>
Garbage collection processes will consume much CPU resources and some memory resources.
So there is not always a garbage collection process in running.
A new garbage collection process will be only triggered when some run-time metrics reach certain conditions.
How the conditions are defined is a garbage collection pacer problem.
</p>


The garbage collection pacer implementation of the official standard Go runtime is still being improved from version to version.
So it is hard to describe the implementation precisely and keep the descriptions up-to-date at the same time.
Here, I just list some reference articles on this topic:

<ul>
<li>
	About <a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables">the <code>GOGC</code> and <code>GOMEMLIMIT</code> environment variables</a> (note that the <code>GOMEMLIMIT</code> environment variable is only supported since Go 1.19).
</li>
<li>
	<a href="https://go.dev/doc/gc-guide">A Guide to the Go Garbage Collector</a>.
</li>
<li>
	<a href="https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md">GC Pacer Redesign</a>.
</li>
<li>
	The "Garbage Collection" chapter of my <a href="https://go101.org/optimizations/101.html">Go Optimizations 101</a> book (it is a paid book).
</li>
</ul>



<!--
Unused heap memory blocks are viewed as garbage by Go runtime and will be collected to reuse or release memory.
The garbage collector is not always running. It will start when a threshold is satisfied.
So an unused memory block may be not collected immediately when it becomes unused.
Instead, it will be collected eventually.
Currently (Go Toolchain 1.20), the threshold is controlled by 
<a href="https://golang.org/pkg/runtime/#hdr-Environment_Variables">GOGC environment variable</a>:
<blockquote style="margin-top:0px;margin-bottom:0px;">
<small>
	The GOGC variable sets the initial garbage collection target percentage.
	A collection is triggered when the ratio of freshly allocated data to
	live data remaining after the previous collection reaches this percentage.
	The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely.
</small>
</blockquote>

<p>
The value of this environment variable determines the frequency of garbage collecting,
and it can be modified at run time by calling
<a href="https://golang.org/pkg/runtime/debug/#SetGCPercent">runtime/debug.SetGCPercent</a> function.
Smaller values lead to more frequent garbage collections.
A negative percentage disables automatic garbage collection.
</p>

<p>
Go Toolchain 1.19 introduced a new scheduling strategy:
the <a href="https://go.dev/doc/gc-guide#Memory_limit">memory limit</a> strategy.
The strategy may be configured may be configured either via the <code>GOMEMLIMIT</code> environment variable
or through the <a href="https://golang.org/pkg/runtime/debug/#SetMemoryLimit">runtime/debug.SetMemoryLimit</a> function. 
This memory limit sets a maximum on the total amount of memory that the Go runtime should use.
In other words, if the total amount of memory Go runtime uses surpasses the limit,
a new garbage collection process will start.
The limit is soft, a Go program will not exit when this limit is exceeded.
The default value of the memory limit is <code>math.MaxInt64</code>,
which effectively disables this strategy.
Please note that, setting a not-large-enough value for the limit may cause the garbage collector to run frequently.
The official runtime implementation tries to limit the CPU usage of the garbage collector to less than 50%
when such situations happen.
</p>

<p>
A garbage collection process can also be started manually by calling the
<a href="https://golang.org/pkg/runtime/#GC">runtime.GC</a> function.
</p>

<p>
One more thing need to note: for the current official Go runtime (v1.20),
<a href="https://github.com/golang/go/blob/895b7c85addfffe19b66d8ca71c31799d6e55990/src/runtime/proc.go#L4481-L4486">a
new garbage collection process will start automatically if garbage collection has not run for two minutes</a>.
</p>

<p>
None of the current supported garbage collection scheduling strategies are good enough to handle all use scenarios,
So more ones might be supported in later official Go runtime versions.
</p>

-->
</div>
<hr>

<div class="text-center"><a href="#i-memory-block.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><b class="index" id="i-memory-block.html">메모리 블록</b></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












