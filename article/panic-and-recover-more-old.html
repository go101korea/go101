<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Explain Panic/Recover Mechanism in Detail -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Explain Panic/Recover Mechanism in Detail</h1>



<p><b><i>
(Note: This is the old version of this article.
This version states a general panic and a Goexit signal are independent of each other,
which is reasonable in my opinion but is inconsistent with the official standard Go runtime implementation.
Before releasing Go Toolchain 1.19, <a href="https://github.com/golang/go/issues/35378">the Go core team clarified that
the official standard Go runtime implementation is okay</a>.
In other words, the clarification thinks a Goexit signal should be viewed as a harmless unrecoverable panic.
Please read <a href="panic-and-recover-more.html">the new version</a> which adpots the clarification.)
</i></b></p>

<p>
Panic and recover mechanism has been
<a href="control-flows-more.html#panic-recover">introduced before</a>,
and several panic/recover use cases are shown in
<a href="panic-and-recover-use-cases.html">the last article</a>.
This current article will explain panic/recover mechanism in detail.
Exiting phases of function calls will also be explained in detail.
</p>

<a class="anchor" id="exiting-phase"></a>
<h3>Exiting Phases of Function Calls</h3>

<div>
<p>
In Go, a function call may undergo an exiting phase before it fully exits.
In the exiting phase, the deferred function calls pushed into the deferred call queue
during executing the function call will be executed (in the inverse pushing order).
When all of the deferred calls fully exit,
the exiting phase ends and the function call also fully exits.
</p>

<p>
Exiting phases might also be called returning phases elsewhere.
</p>

A function call may enter its exiting phase (or exit directly) through three ways:
<ol>
<li>
	after the call returns normally.
</li>
<li>
	when a panic occurs in the call.
</li>
<li>
	after the <code>runtime.Goexit</code> function is called and fully exits in the call.
</li>
</ol>

For example, in the following code snippet,
<ul>
<li>
	a call to the function <code>f0</code> or <code>f1</code>
	will enter its existing phase after it returns normally.
</li>
<li>
	a call to the function <code>f2</code> will enter its exiting phase
	after the divided-by-zero panic happens.
</li>
<li>
	a call to the function <code>f3</code> will enter its exiting phase
	after the <code>runtime.Goexit</code> function call fully exits.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">import (
	"fmt"
	"runtime"
)

func f0() int {
	var x = 1
	defer fmt.Println("exits normally:", x)
	x++
	return x
}

func f1() {
	var x = 1
	defer fmt.Println("exits normally:", x)
	x++
}

func f2() {
	var x, y = 1, 0
	defer fmt.Println("exits for panicking:", x)
	x = x / y // will panic
	x++       // unreachable
}

func f3() int {
	x := 1
	defer fmt.Println("exits for Goexiting:", x)
	x++
	runtime.Goexit()
	return x+x // unreachable
}
</code></pre>

<p>
</p>
</div>

<a class="anchor" id="function-call-assosiations"></a>
<h3>Associating Panics and Goexit Signals of Function Calls</h3>
<div>

<p><b><i>
(Note: Again, the explanations in this section conflict with the official standard Go runtime implementation.
Please read <a href="panic-and-recover-more.html">the new version</a> which is consistent with the official standard Go runtime implementation.)
</i></b></p>

<p>
When a panic occurs directly in a function call, we say the (unrecovered) panic starts associating with the function call.
Similarly, when the <code>runtime.Goexit</code> function is called in a function call,
we say a Goexit signal starts associating with the function call after the <code>runtime.Goexit</code> call fully exits.
A panic and a Goexit signal are independent of each other.
As explained in the last section,
associating either a panic or a Goexit signal with a function call
will make the function call enter its exiting phase immediately.
</p>

<p>
We have learned that <a href="control-flows-more.html#panic-recover">panics can be recovered</a>.
However, there are no ways to cancel a Goexit signal.
</p>

At any give time, a function call may associate with at most one unrecovered panic.
If a call is associating with an unrecovered panic, then
<ul>
<li>
	the call will associate with no panics when the unrecovered panic is recovered.
</li>
<li>
	when a new panic occurs in the function call, the new one will replace
	the old one to be the associating unrecovered panic of the function call.
</li>
</ul>

For example, in the following program, the recovered panic is panic 3,
which is the last panic associating with the <code>main</code> function call.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	defer func() {
		fmt.Println(recover()) // 3
	}()
	
	defer panic(3) // will replace panic 2
	defer panic(2) // will replace panic 1
	defer panic(1) // will replace panic 0
	panic(0)
}
</code></pre>

<p>
</p>

<p>
As Goexit signals can't be cancelled,
arguing whether a function call may associate with at most one or more than one Goexit signal is unnecessary.
</p>

Although it is unusual, there might be multiple unrecovered panics coexisting in a goroutine at a time.
Each one associates with one non-exited function call in the call stack of the goroutine.
When a nested call still associating with an unrecovered panic fully exits,
the unrecovered panic will spread to the nesting call (the caller of the nested call).
The effect is the same as a panic occurs directly in the nesting call.
That says,
<ul>
<li>
	if there was an old unrecovered panic associating with the nesting call before,
	the old one will be replaced by the spread one.
	For this case, the nesting call has already entered its exiting phase for sure,
	so the next deferred function call in the deferred call queue will be invoked.
</li>
<li>
	if there was not an unrecovered panic associating with the nesting call before,
	the spread one will associates with the nesting call.
	For this case, the nesting call might have entered its exiting phase or not.
	If it hasn't, it will enter its exiting phase immediately.
</li>
</ul>

<p>
So, when a goroutine finishes to exit, there may be at most one unrecovered panic in the goroutine.
If a goroutine exits with an unrecovered panic, the whole program crashes.
The information of the unrecovered panic will be reported when the program crashes.
</p>

<p>
When a function is invoked, there is neither a panic nor Goexit signals associating with its call initially,
no matter whether its caller (the nesting call) has entered exiting phase or not.
Surely, panics might occur or the <code>runtime.Goexit</code> function might be called later
in the process of executing the call, so panics and Goexit signals might associate with the call later.
</p>

The following example program will crash if it runs,
because the panic 2 is still not recovered when the new goroutine exits.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	// The new goroutine.
	go func() {
		// The anonymous deferred call.
		// When it fully exits, the panic 2 will spread
		// to the entry function call of the new
		// goroutine, and replace the panic 0. The
		// panic 2 will never be recovered.
		defer func() {
			// As explained in the last example,
			// panic 2 will replace panic 1.
			defer panic(2)
			
			// When the anonymous function call fully
			// exits, panic 1 will spread to (and
			// associate with) the nesting anonymous
			// deferred call.
			func () {
				panic(1)
				// Once the panic 1 occurs, there will
				// be two unrecovered panics coexisting
				// in the new goroutine. One (panic 0)
				// associates with the entry function
				// call of the new goroutine, the other
				// (panic 1) associates with the
				// current anonymous function call.
			}()
		}()
		panic(0)
	}()
	
	select{}
}
</code></pre>

The output (when the above program is compiled with the standard Go compiler v1.19):
<pre class="output"><code>panic: 0
	panic: 1
	panic: 2

goroutine 5 [running]:
...
</code></pre>

<p>
The format of the output is not perfect, it is prone to make some people think that the panic 0 is the final unrecovered panic,
whereas the final unrecovered panic is panic 2 actually.
</p>

<p>
Similarly, when a nested call fully exits and it is associating with a Goexit signal,
then the Goexit signal will also spread to (and associate with) the nesting call.
This will make the nesting call enter (if it hasn't entered) its exiting phase immediately.
</p>

The above has mentioned that a panic and a Goexit signal are independent of each other.
In other words, an unrecovered panic should not cancel a Goexit signal,
and a Goexit signal should not shadow an unrecovered panic or be cancelled.
However, both of the current official standard Go compiler (gc, v1.19) and gccgo (v10)
don't implement this rule correctly.
For example, the following program should crash but it doesn't
if it is compiled with the current versions of gc and gccgo.

<pre class="line-numbers"><code class="language-go">package main

import "runtime"

func f() {
	// The Goexit signal shadows the "bye"
	// panic now, but it should not.
	defer runtime.Goexit()
	panic("bye")
}

func main() {
	go f()
	
	for runtime.NumGoroutine() > 1 {
		runtime.Gosched()
	}
}
</code></pre>

<p>
<a href="https://github.com/golang/go/issues/35378">The problem</a> will be fixed in future versions of gc and gccgo.
</p>

The following example program should exit quickly in running,
but it will not compile correctly with the current gccgo version (v8.0) and gc versions before Go Toolchain 1.14.
In fact, it never exits if it compiles with those compiler versions.

<pre class="line-numbers"><code class="language-go">package main

import "runtime"

func f() {
	defer func() {
		recover()
	}()
	defer panic("will cancel Goexit but should not")
	runtime.Goexit()
}

func main() {
	c := make(chan struct{})
	go func() {
		defer close(c)
		f()
		for {
			runtime.Gosched()
		}
	}()
	<-c
}
</code></pre>

<p>
Since Go Toolchain 1.14, <a href="https://github.com/golang/go/issues/29226">the problem</a> has been fixed in the standard compiler (gc).
</p>

</div>

<a class="anchor" id="some-recovers-are-no-ops"></a>
<h3>Some <code>recover</code> Calls Are No-Ops</h3>
<div>

The builtin <code>recover</code> function must be called at proper places to take effect.
Otherwise, the calls are no-ops.
For example, none of the <code>recover</code> calls in the following example recover the <code>bye</code> panic.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	defer func() {
		defer func() {
			recover() // no-op
		}()
	}()
	defer func() {
		func() {
			recover() // no-op
		}()
	}()
	func() {
		defer func() {
			recover() // no-op
		}()
	}()
	func() {
		defer recover() // no-op
	}()
	func() {
		recover() // no-op
	}()
	recover()       // no-op
	defer recover() // no-op
	panic("bye")
}
</code></pre>

<p>
</p>

We have already known that the following <code>recover</code> call takes effect.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	defer func() {
		recover() // take effect
	}()

	panic("bye")
}
</code></pre>

<p>
</p>


Then why don't those <code>recover</code> calls in the first example in the current section take effect?
Let's read the current version of <a href="https://golang.org/ref/spec#Handling_panics">Go specification</a>:

<div class="alert alert-success">
The return value of <code>recover</code> is <code>nil</code> if any of the following conditions holds:
<ul>
<li>panic's argument was nil;</li>
<li>the goroutine is not panicking;</li>
<li>recover was not called directly by a deferred function.</li>
</ul>
</div>

<p>
There is <a href="panic-and-recover-use-cases.html#avoid-verbose">an example</a>
showing the first condition case in the last article.
</p>

<p>
Most of the <code>recover</code> calls in the first example in the current section satisfy
either the second or the third conditions mentioned in Go specification,
except the first call. Yes, the current descriptions are not precise yet.
It is still <a href="https://go-review.googlesource.com/c/go/+/189377">being improved</a> now.
</p>

In fact, the current Go specification also doesn't explain well why the second
<code>recover</code> call, which is expected to recover panic 1,
in the following example doesn't take effect.

<pre class="line-numbers"><code class="language-go">// This program exits without recovering panic 1.
package main

func demo() {
	defer func() {
		defer func() {
			recover() // this one recovers panic 2
		}()

		defer recover() // no-op

		panic(2)
	}()
	panic(1)
}

func main() {
	demo()
}
</code></pre>

<p>
What Go specification doesn't mention is that,
at any given time, only the newest unrecovered panic in a goroutine is recoverable.
In other words, each <code>recover</code> call is viewed as an attempt
to recover the newest unrecovered panic in the current goroutine.
This is why the second <code>recover</code> call in the above example is a no-op.
</p>


OK, now, let's try to make a short description on which <code>recover</code> calls will take effect:
<div class="alert alert-warning">
A <code>recover</code> call takes effect only if the direct caller of
the <code>recover</code> call is a deferred call and
the direct caller of the deferred call associates with
the newest unrecovered panic in the current goroutine.
An effective <code>recover</code> call disassociates the
newest unrecovered panic from its associating function call,
and returns the value passed to the <code>panic</code> call which produced the newest unrecovered panic. 
</div>

</div>

<!--
other bugs:
* https://github.com/golang/go/issues/43942
* https://github.com/golang/go/issues/43941
* https://github.com/golang/go/issues/43921
* https://github.com/golang/go/issues/43920
-->


<hr>

<div class="text-center"><a href="#i-panic-and-recover-more-old.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












