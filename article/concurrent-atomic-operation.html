<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Atomic Operations Provided in The sync/atomic Standard Package -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Atomic Operations Provided in The <code>sync/atomic</code> Standard Package</h1>



<p>
Atomic operations are more primitive than other synchronization techniques.
They are lockless and generally implemented directly at hardware level.
In fact, they are often used in implementing other synchronization techniques.
</p>

<p>
Please note, many examples below are not concurrent programs.
They are just for demonstration and explanation purposes, to show how to use the
atomic functions provided in the <code>sync/atomic</code> standard package.
</p>

<a class="anchor" id="overview"></a>
<h3>Overview of Atomic Operations Provided Before Go 1.19-</h3>

<div>

The <code>sync/atomic</code> standard package provides the following five atomic functions
for an integer type <code>T</code>, where <code>T</code> must be any of <code>int32</code>,
<code>int64</code>, <code>uint32</code>, <code>uint64</code> and <code>uintptr</code>.

<pre class="line-numbers must-line-numbers"><code class="language-go">func AddT(addr *T, delta T)(new T)
func LoadT(addr *T) (val T)
func StoreT(addr *T, val T)
func SwapT(addr *T, new T) (old T)
func CompareAndSwapT(addr *T, old, new T) (swapped bool)
</code></pre>

For example, the following five functions are provided for type <code>int32</code>.
<pre class="line-numbers must-line-numbers"><code class="language-go">func AddInt32(addr *int32, delta int32)(new int32)
func LoadInt32(addr *int32) (val int32)
func StoreInt32(addr *int32, val int32)
func SwapInt32(addr *int32, new int32) (old int32)
func CompareAndSwapInt32(addr *int32,
				old, new int32) (swapped bool)
</code></pre>

<p>
</p>

The following four atomic functions are provided for (safe) pointer types.
When these functions were introduced into the standard library,
Go didn't support custom generics, so these functions are implemented
through the <a href="unsafe.html">unsafe pointer type</a> <code>unsafe.Pointer</code>
(the Go counterpart of C <code>void*</code>).
<pre class="line-numbers must-line-numbers"><code class="language-go">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)
func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)
func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer,
				) (old unsafe.Pointer)
func CompareAndSwapPointer(addr *unsafe.Pointer,
				old, new unsafe.Pointer) (swapped bool)
</code></pre>

<p>
There is not an <code>AddPointer</code> function for pointers,
as Go (safe) pointers don't support arithmetic operations.
</p>

The <code>sync/atomic</code> standard package also provides a type <code>Value</code>,
which corresponding pointer type <code>*Value</code> has four methods
(listed below, the later two were introduced by Go 1.17).
We may use these methods to do atomic operations for values of any type.

<pre class="line-numbers"><code class="language-go">func (*Value) Load() (x interface{})
func (*Value) Store(x interface{})
func (*Value) Swap(new interface{}) (old interface{})
func (*Value) CompareAndSwap(old, new interface{}) (swapped bool)
</code></pre>

</div>

<a class="anchor" id="overview-1.19"></a>
<h3>Overview of New Atomic Operations Provided Since Go 1.19</h3>

<div>

<p>
Go 1.19 introduced several types, each of which owns a set of atomic operation methods,
to achieve the same effects made by the package-level functions listed in the last section.
</p>

<p>
Among these types, <code>Int32</code>, <code>Int64</code>, <code>Uint32</code>,
<code>Uint64</code> and <code>Uintptr</code> are for integer atomic operations.
The methods of the <code>atomic.Int32</code> type are listed below.
The methods of the other four types present in the similar way.
</p>

<pre class="line-numbers"><code class="language-go">func (*Int32) Add(delta int32) (new int32)
func (*Int32) Load() int32
func (*Int32) Store(val int32)
func (*Int32) Swap(new int32) (old int32)
func (*Int32) CompareAndSwap(old, new int32) (swapped bool)
</code></pre>

<p>
Since Go 1.18, Go has already supported custom generics.
And some standard packages started to adopt custom generics since Go 1.19.
The <code>sync/atomic</code> package is one of these packages.
The <code>Pointer[T any]</code> type introudced in this package by Go 1.19 is a generic type.
Its methods are listed below.
</p>

<pre class="line-numbers"><code class="language-go">(*Pointer[T]) Load() *T
(*Pointer[T]) Store(val *T)
(*Pointer[T]) Swap(new *T) (old *T)
(*Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)
</code></pre>

<p>
Go 1.19 also introduced a <code>Bool</code> type to do boolean atomic operations.
</p>

</div>

<a class="anchor" id="integer"></a>
<h3>Atomic Operations for Integers</h3>

<div>
<p>
The remaining of this article shows some examples on how to use the atomic operations provided in Go.
</p>

The following example shows how to do the <code>Add</code> atomic operation
on an <code>int32</code> value by using the <code>AddInt32</code> function.
In this example, 1000 new concurrent goroutines are created by the main goroutine.
Each of the new created goroutine increases the integer <code>n</code> by one.
Atomic operations guarantee that there are no data races among these goroutines.
In the end, <code>1000</code> is guaranteed to be printed.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var n int32
	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			atomic.AddInt32(&n, 1)
			wg.Done()
		}()
	}
	wg.Wait()

	fmt.Println(atomic.LoadInt32(&n)) // 1000
}
</code></pre>

<p>
If the statement <code>atomic.AddInt32(&amp;n, 1)</code> is replaced with <code>n++</code>,
then the output might be not <code>1000</code>.
</p>

The following code re-implements the above program by using the <code>atomic.Int32</code> type and its methods (since Go 1.19).
This code looks a bit tidier.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var n atomic.Int32
	var wg sync.WaitGroup
	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			n.Add(1)
			wg.Done()
		}()
	}
	wg.Wait()

	fmt.Println(n.Load()) // 1000
}
</code></pre>

<p>
</p>

The <code>StoreT</code> and <code>LoadT</code> atomic functions/methods are often used
to implement the setter and getter methods of (the corresponding pointer type of)
a type if the values of the type need to be used concurrently.
For example, the function version:

<pre class="line-numbers"><code class="language-go">type Page struct {
	views uint32
}

func (page *Page) SetViews(n uint32) {
	atomic.StoreUint32(&page.views, n)
}

func (page *Page) Views() uint32 {
	return atomic.LoadUint32(&page.views)
}
</code></pre>

And the type+methods version (since Go 1.19):

<pre class="line-numbers"><code class="language-go">type Page struct {
	views atomic.Uint32
}

func (page *Page) SetViews(n uint32) {
	page.views.Store(n)
}

func (page *Page) Views() uint32 {
	return page.views.Load()
}
</code></pre>

<p>
</p>

For a signed integer type <code>T</code> (<code>int32</code> or <code>int64</code>),
the second argument for a call to the <code>AddT</code> function can be a negative value,
to do an atomic decrease operation.
But how to do atomic decrease operations for values of an unsigned type <code>T</code>,
such as <code>uint32</code>, <code>uint64</code> and <code>uintptr</code>?
There are two circumstances for the second unsigned arguments.
<ol>
<li>
	For an unsigned variable <code>v</code> of type <code>T</code>,
	<code>-v</code> is legal in Go.
	So we can just pass <code>-v</code> as the second argument of an <code>AddT</code> call.
</li>
<li>
	For a positive constant integer <code>c</code>,
	<code>-c</code> is illegal to be used as the second argument of an <code>AddT</code> call
	(where <code>T</code> denotes an unsigned integer type).
	We can used <code>^T(c-1)</code> as the second argument instead.
</li>
</ol>

<p>
</p>

<p>
This <code>^T(v-1)</code> trick also works for an unsigned variable <code>v</code>,
but <code>^T(v-1)</code> is less efficient than <code>T(-v)</code>.
</p>

<p>
In the trick <code>^T(c-1)</code>, if <code>c</code> is a typed value
and its type is exactly <code>T</code>, then the form can shortened as <code>^(c-1)</code>.
</p>

Example:

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	var (
		n uint64 = 97
		m uint64 = 1
		k int    = 2
	)
	const (
		a        = 3
		b uint64 = 4
		c uint32 = 5
		d int    = 6
	)

	show := fmt.Println
	atomic.AddUint64(&n, -m)
	show(n) // 96 (97 - 1)
	atomic.AddUint64(&n, -uint64(k))
	show(n) // 94 (96 - 2)
	atomic.AddUint64(&n, ^uint64(a - 1))
	show(n) // 91 (94 - 3)
	atomic.AddUint64(&n, ^(b - 1))
	show(n) // 87 (91 - 4)
	atomic.AddUint64(&n, ^uint64(c - 1))
	show(n) // 82 (87 - 5)
	atomic.AddUint64(&n, ^uint64(d - 1))
	show(n) // 76 (82 - 6)
	x := b; atomic.AddUint64(&n, -x)
	show(n) // 72 (76 - 4)
	atomic.AddUint64(&n, ^(m - 1))
	show(n) // 71 (72 - 1)
	atomic.AddUint64(&n, ^uint64(k - 1))
	show(n) // 69 (71 - 2)
}
</code></pre>

<p>
</p>

<p>
A <code>SwapT</code> function call is like a <code>StoreT</code> function call,
but returns the old value.
</p>

<p>
A <code>CompareAndSwapT</code> function call only applies the store operation
when the current value matches the passed old value.
The <code>bool</code> return result of the <code>CompareAndSwapT</code>
function call indicates whether or not the store operation is applied.
</p>

Example:
<pre class="line-numbers must-line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	var n int64 = 123
	var old = atomic.SwapInt64(&n, 789)
	fmt.Println(n, old) // 789 123
	swapped := atomic.CompareAndSwapInt64(&n, 123, 456)
	fmt.Println(swapped) // false
	fmt.Println(n)       // 789
	swapped = atomic.CompareAndSwapInt64(&n, 789, 456)
	fmt.Println(swapped) // true
	fmt.Println(n)       // 456
}
</code></pre>

The following is the corresponding type+methods version (since Go 1.19):

<pre class="line-numbers must-line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	var n atomic.Int64
	n.Store(123)
	var old = n.Swap(789)
	fmt.Println(n.Load(), old) // 789 123
	swapped := n.CompareAndSwap(123, 456)
	fmt.Println(swapped)  // false
	fmt.Println(n.Load()) // 789
	swapped = n.CompareAndSwap(789, 456)
	fmt.Println(swapped)  // true
	fmt.Println(n.Load()) // 456
}
</code></pre>

<p>
</p>

<p>
Please note, up to now (Go 1.20), atomic operations for 64-bit words,
a.k.a. int64 and uint64 values,
require the 64-bit words must be 8-byte aligned in memory.
For Go 1.19 introduced atomic method operations, this requirement is always satisfied,
either on 32-bit or 64-bit architectures,
but this is not true for atomic function operations on 32-bit architectures.
Please read <a href="memory-layout.html">memory layout</a> for details.
</p>

</div>

<a class="anchor" id="pointer"></a>
<h3>Atomic Operations for Pointers</h3>

<div>
<p>
Above has mentioned that there are four functions provided in the
<code>sync/atomic</code> standard package to do atomic pointer operations,
with the help of unsafe pointers.
</p>

<p>
From the article <a href="unsafe.html">type-unsafe pointers</a>, we learn that,
in Go, values of any pointer type can be explicitly converted to <code>unsafe.Pointer</code>, and vice versa.
So values of <code>*unsafe.Pointer</code> type can also be explicitly converted to <code>unsafe.Pointer</code>, and vice versa.
</p>

The following example is not a concurrent program.
It just shows how to do atomic pointer operations.
In this example, <code>T</code> can be an arbitrary type.
<pre class="line-numbers must-line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
	"unsafe"
)

type T struct {x int}

func main() {
	var pT *T
	var unsafePPT = (*unsafe.Pointer)(unsafe.Pointer(&pT))
	var ta, tb = T{1}, T{2}
	// store
	atomic.StorePointer(
		unsafePPT, unsafe.Pointer(&ta))
	fmt.Println(pT) // &{1}
	// load
	pa1 := (*T)(atomic.LoadPointer(unsafePPT))
	fmt.Println(pa1 == &ta) // true
	// swap
	pa2 := atomic.SwapPointer(
		unsafePPT, unsafe.Pointer(&tb))
	fmt.Println((*T)(pa2) == &ta) // true
	fmt.Println(pT) // &{2}
	// compare and swap
	b := atomic.CompareAndSwapPointer(
		unsafePPT, pa2, unsafe.Pointer(&tb))
	fmt.Println(b) // false
	b = atomic.CompareAndSwapPointer(
		unsafePPT, unsafe.Pointer(&tb), pa2)
	fmt.Println(b) // true
}
</code></pre>

<p>
Yes, it is quite verbose to use the pointer atomic functions.
In fact, not only are the uses verbose, they are also not protected by
<a href="https://golang.org/doc/go1compat">Go 1 compatibility guidelines</a>,
for these uses require to import the <code>unsafe</code> standard package.
</p>

<!--
<p>
Personally, I think the possibility is small that the legal pointer value
atomic operations used in the above example will become illegal later.
Even if they become illegal later, the <code>go fix</code> command provided in
Go Toolchain should fix them with a later alternative new legal way.
But, this is just my opinion, which is not authoritative.
</p>

<p>
If you do worry about the future legality of the pointer atomic operations used
in the above example, you can use the atomic operations introduced in the next
section for pointers, though the to be introduced operations are less
efficient than the ones introduced in the current section.
</p>
-->

<p>
On the contrary, the code will be much simpler and cleaner if
we use the Go 1.19 introduced generic <code>Pointer</code> type and its methods
to do atomic pointer operations, as the following code shows.
</p>

<pre class="line-numbers must-line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

type T struct {x int}

func main() {
	var pT atomic.Pointer[T]
	var ta, tb = T{1}, T{2}
	// store
	pT.Store(&ta)
	fmt.Println(pT.Load()) // &{1}
	// load
	pa1 := pT.Load()
	fmt.Println(pa1 == &ta) // true
	// swap
	pa2 := pT.Swap(&tb)
	fmt.Println(pa2 == &ta) // true
	fmt.Println(pT.Load())  // &{2}
	// compare and swap
	b := pT.CompareAndSwap(&ta, &tb)
	fmt.Println(b) // false
	b = pT.CompareAndSwap(&tb, &ta)
	fmt.Println(b) // true
}
</code></pre>

<p>
More importantly, the implementation using the generic <code>Pointer</code> type
is protected by Go 1 compatibility guidelines.
</p>

</div>

<a class="anchor" id="arbitrary"></a>
<h3>Atomic Operations for Values of Arbitrary Types</h3>

<div>
<p>
The <code>Value</code> type provided in the <code>sync/atomic</code> standard package
can be used to atomically load and store values of any type.
</p>

<p>
Type <code>*Value</code> has several methods: <code>Load</code>, <code>Store</code>,
<code>Swap</code> and <code>CompareAndSwap</code> (The latter two are introduced in Go 1.17).
The input parameter types of these methods are all <code>interface{}</code>.
So any value may be passed to the calls to these methods.
But for an addressable <code>Value</code> value <code>v</code>,
once the <code>v.Store()</code> (a shorthand of <code>(&amp;v).Store()</code>)
call has ever been called,
then the subsequent method calls on value <code>v</code> must also take argument values
with the same <a href="type-system-overview.html#concrete-type">concrete type</a>
as the argument of the first <code>v.Store()</code> call,
otherwise, panics will occur.
A <code>nil</code> interface argument will also make the <code>v.Store()</code> call panic.
</p>

An example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	type T struct {a, b, c int}
	var ta = T{1, 2, 3}
	var v atomic.Value
	v.Store(ta)
	var tb = v.Load().(T)
	fmt.Println(tb)       // {1 2 3}
	fmt.Println(ta == tb) // true

	v.Store("hello") // will panic
}
</code></pre>

Another example (for Go 1.17+):
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync/atomic"
)

func main() {
	type T struct {a, b, c int}
	var x = T{1, 2, 3}
	var y = T{4, 5, 6}
	var z = T{7, 8, 9}
	var v atomic.Value
	v.Store(x)
	fmt.Println(v) // {{1 2 3}}
	old := v.Swap(y)
	fmt.Println(v)       // {{4 5 6}}
	fmt.Println(old.(T)) // {1 2 3}
	swapped := v.CompareAndSwap(x, z)
	fmt.Println(swapped, v) // false {{4 5 6}}
	swapped = v.CompareAndSwap(y, z)
	fmt.Println(swapped, v) // true {{7 8 9}}
}
</code></pre>

<p>
In fact, we can also use the atomic pointer functions explained in the last section
to do atomic operations for values of any type, with one more level indirection.
Both ways have their respective advantages and disadvantages.
Which way should be used depends on the requirements in practice.
</p>

</div>

<h3>Memory Order Guarantee Made by Atomic Operations in Go</h3>

<p>
For easy using, Go atomic operations provided in the <code>sync/atomic</code>
standard package are designed without any relations to memory ordering.
At least the official documentation doesn't specify any memory order guarantees
made by the <code>sync/atomic</code> standard package.
Please read <a href="memory-model.html#atomic">Go memory model</a> for details.
</p>

<hr>

<div class="text-center"><a href="#i-concurrent-atomic-operation.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><b class="index" id="i-concurrent-atomic-operation.html">원자적 연산</b> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












