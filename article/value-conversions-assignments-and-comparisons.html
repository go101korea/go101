<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Value Conversion, Assignment and Comparison Rules in Go -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Value Conversion, Assignment and Comparison Rules in Go</h1>



<p>
This article will list all the value comparison, conversion and comparison rules in Go.
Please note that type parameter types (used frequently in custom generics) are deliberately ignored
in the descriptions of conversion, assignability and comparison rules.
In other words, this book doesn't consider the situations in which
<a href="https://go101.org/generics/101.html">custom generics</a> are involved.
</p>

<a class="anchor" id="conversion"></a>
<h3>Value Conversion Rules</h3>

<!--
<p>
Note, the definition of conversion in Go 101 is not exactly the same as Go specification.
The conversion in Go spec means explicit conversion.
The conversions in Go 101 include both explicit and implicit conversions.
</p>
-->

<p>
In Go, if a value <code>v</code> can be explicitly converted to type <code>T</code>,
the conversion can be represented as the form <code>(T)(v)</code>.
For most cases, in particular <code>T</code> is a type name (an identifier),
the form can be simplified to <code>T(v)</code>.
</p>

<p>
One fact we should know is,
when it says a value <code>x</code> can be implicitly converted to a type <code>T</code>,
then it means <code>x</code> can also be explicitly converted to type <code>T</code>.
</p>

<h4>1. the apparent conversion rule</h4>

<div class="well">
If two types denote the identical type,
then their values can be <b>implicitly</b> converted to either type of the two.
</div>

<div>
For example,
<ul>
<li>
	values of type <code>byte</code> and <code>uint8</code> can be converted to each other.
</li>
<li>
	values of type <code>rune</code> and <code>int32</code> can be converted to each other.
</li>
<li>
	values of type <code>[]byte</code> and <code>[]uint8</code> can be converted to each other.
</li>
</ul>
</div>

<p>
Nothing more to explain about this rule, whether you think this case involves conversions or not.
</p>

<a class="anchor" id="conversion-rule-underlying-types"></a>
<h4>2. underlying type related conversion rules</h4>

<div class="well">
Given a non-interface value <code>x</code> and a non-interface type <code>T</code>, assume the type of <code>x</code> is <code>Tx</code>,
<ul>
<li>
	if <code>Tx</code> and <code>T</code> share the same <a href="type-system-overview.html#underlying-type">underlying type</a> (ignoring struct tags),
	then <code>x</code> can be explicitly converted to <code>T</code>.
</li>
<li>
	if either <code>Tx</code> or <code>T</code> is a <a href="type-system-overview.html#named-type">unnamed type</a>
	and their underlying types are identical (considering struct tags),
	then <code>x</code> can be <b>implicitly</b> converted to <code>T</code>.
</li>
<li>
	if <code>Tx</code> and <code>T</code> have different underlying types,
	but both <code>Tx</code> and <code>T</code> are unnamed pointer types
	and their base types share the same underlying type (ignoring struct tags),
	then <code>x</code> can be explicitly converted to <code>T</code>.
</li>
</ul>
</div>

<p><i>
(Note, the two <b>ignoring struct tags</b> occurrences have taken effect since Go 1.8.)
</i></p>

<div>
An example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// []int, IntSlice and MySlice share
	// the same underlying type: []int
	type IntSlice []int
	type MySlice  []int
	type Foo = struct{n int `foo`}
	type Bar = struct{n int `bar`}

	var s  = []int{}
	var is = IntSlice{}
	var ms = MySlice{}
	var x map[Bar]Foo
	var y map[Foo]Bar

	// The two implicit conversions both doesn't work.
	/*
	is = ms // error
	ms = is // error
	*/

	// Must use explicit conversions here.
	is = IntSlice(ms)
	ms = MySlice(is)
	x = map[Bar]Foo(y)
	y = map[Foo]Bar(x)

	// Implicit conversions are okay here.
	s = is
	is = s
	s = ms
	ms = s
}
</code></pre>

<p>
</p>

Pointer related conversion example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	type MyInt int
	type IntPtr *int
	type MyIntPtr *MyInt

	var pi = new(int)  // the type of pi is *int
	// ip and pi have the same underlying type,
	// and the type of pi is unnamed, so
	// the implicit conversion works.
	var ip IntPtr = pi

	// var _ *MyInt = pi // can't convert implicitly
	var _ = (*MyInt)(pi) // ok, must explicitly

	// Values of *int can't be converted to MyIntPtr
	// directly, but can indirectly.
	/*
	var _ MyIntPtr = pi  // can't convert implicitly
	var _ = MyIntPtr(pi) // can't convert explicitly
	*/
	var _ MyIntPtr = (*MyInt)(pi)  // ok
	var _ = MyIntPtr((*MyInt)(pi)) // ok

	// Values of IntPtr can't be converted to
	// MyIntPtr directly, but can indirectly.
	/*
	var _ MyIntPtr = ip  // can't convert implicitly
	var _ = MyIntPtr(ip) // can't convert explicitly
	*/
	var _ MyIntPtr = (*MyInt)((*int)(ip))  // ok
	var _ = MyIntPtr((*MyInt)((*int)(ip))) // ok
}
</code></pre>
</div>

<h4>3. channel specific conversion rule</h4>

<div class="well">
	Given a channel value <code>x</code>, assume its type <code>Tx</code> is a
	bidirectional channel type, <code>T</code> is also a channel type (bidirectional or not).
	If <code>Tx</code> and <code>T</code> have the identical element type,
	and either <code>Tx</code> or <code>T</code> is an unnamed type,
	then <code>x</code> can be <b>implicitly</b> converted to <code>T</code>.
</div>

<!--
a potential bug: https://github.com/golang/go/issues/29469
-->

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	type C chan string
	type C1 chan<- string
	type C2 <-chan string

	var ca C
	var cb chan string

	cb = ca // ok, same underlying type
	ca = cb // ok, same underlying type

	// The 4 lines compile okay for this 3rd rule.
	var _, _ chan<- string = ca, cb // ok
	var _, _ <-chan string = ca, cb // ok
	var _ C1 = cb                   // ok
	var _ C2 = cb                   // ok

	// Values of C can't be converted
	// to C1 and C2 directly.
	/*
	var _ = C1(ca) // compile error
	var _ = C2(ca) // compile error
	*/

	// Values of C can be converted
	// to C1 and C2 indirectly.
	var _ = C1((chan<- string)(ca)) // ok
	var _ = C2((<-chan string)(ca)) // ok
	var _ C1 = (chan<- string)(ca)  // ok
	var _ C2 = (<-chan string)(ca)  // ok
}
</code></pre>
</div>

<a class="anchor" id="conversion-rule-implementation"></a>
<h4>4. interface implementation related conversion rules</h4>

<div class="well">
Given a value <code>x</code> and an interface type <code>I</code>,
if the type (or the default type) of <code>x</code> is <code>Tx</code>
and <code>Tx</code> implements <code>I</code>,
then <code>x</code> can be <b>implicitly</b> converted to type <code>I</code>.
The conversion result is an interface value (of type <code>I</code>),
which boxes
<ul>
<li>a copy of <code>x</code>, if <code>Tx</code> is a non-interface type;</li>
<li>a copy of the dynamic value of <code>x</code>, if <code>Tx</code> is an interface type.</li>
</ul>
</div>

<!--div class="well">
Given an interface value <code>x</code> with its dynamic type as <code>T</code>,
<code>x</code> can be safely converted to type <code>T</code> through
the type assertion syntax <code>x.(T)</code>.
</div>

<div class="well">
Given an interface value <code>x</code> and an interface type <code>I</code>,
if the dynamic type of <code>x</code> implements <code>I</code>,
then <code>x</code> can be safely converted to <code>I</code>
through the type assertion syntax <code>x.(I)</code>.
</div-->

<p>
Please read <a href="interface.html">interfaces in Go</a> for details and examples.
</p>

<h4>5. untyped value conversion rule</h4>

<div class="well">
An untyped value can be <b>implicitly</b> converted to type <code>T</code>,
if the untyped value can represent as values of type <code>T</code>.
</div>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	var _ []int = nil
	var _ map[string]int = nil
	var _ chan string = nil
	var _ func()() = nil
	var _ *bool = nil
	var _ interface{} = nil

	var _ int = 123.0
	var _ float64 = 123
	var _ int32 = 1.23e2
	var _ int8 = 1 + 0i
}
</code></pre>
</div>

<h4>6. constants conversion rule</h4>

<p><i>
(This rule is some overlapped with the last one.)
</i></p>

<p>
Generally, converting a constant still yields a constant as result.
(Except converting a constant string to byte slice or rune slice
described in the below 8th rules.)
</p>

<div class="well">
Given a constant value <code>x</code> and a type <code>T</code>, if <code>x</code> is representable as a value of type <code>T</code>,
then <code>x</code> can be explicitly converted to <code>T</code>. In particular if <code>x</code> is an untyped value,
then <code>x</code> can be <b>implicitly</b> converted to <code>T</code>.
</div>

<!--
<p>
Note, in case of <code>x</code> is a floating-point constant and <code>T</code> is a floating-point type,
the conversion result <code>T(x)</code> is the rounded value of <code>x</code> by using IEEE 754 round-to-even rules,
but with an IEEE <code>-0.0</code> further rounded to an unsigned <code>0.0</code>.
</p>
-->

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	const I = 123
	const I1, I2 int8 = 0x7F, -0x80
	const I3, I4 int8 = I, 0.0

	const F = 0.123456789
	const F32 float32 = F
	const F32b float32 = I
	const F64 float64 = F
	const F64b = float64(I3) // must be explicitly

	const C1, C2 complex64 = F, I
	const I5 = int(C2) // must be explicitly
}
</code></pre>
</div>

<h4>7. non-constant number conversion rules</h4>

<div class="well">
Non-constant floating-point and integer values can be explicitly
converted to any floating-point and integer types.
</div>

<div class="well">
Non-constant complex values can be explicitly converted to any complex types.
</div>

<div>
Note,
<ul>
<li>Complex non-constant values can't be converted to floating-point and integer types.</li>
<li>Floating-point and integer non-constant values can't be converted to complex types.</li>
<li>Data overflow and rounding are allowed in non-constant number conversions.
	When converting a floating-point non-constant number to an integer, the fraction is discarded (truncation towards zero).
</li>
</ul>

An example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	var a, b = 1.6, -1.6 // both are float64
	fmt.Println(int(a), int(b)) // 1 -1

	var i, j int16 = 0x7FFF, -0x8000
	fmt.Println(int8(i), uint16(j)) // -1 32768

	var c1 complex64 = 1 + 2i
	var _ = complex128(c1)
}
</code></pre>
</div>

<h4>8. string related conversion rules</h4>

<div class="well">
If the type (or default type) of a value is an integer type,
then the value can be explicitly converted to string types.
</div>

<div class="well">
A string value can be explicitly converted to a slice type
whose underlying type is <code>[]byte</code> (a.k.a., <code>[]uint8</code>),
and vice versa.
</div>

<div class="well">
A string value can be explicitly converted to a slice type
whose underlying type is <code>[]rune</code> (a.k.a., <code>[]int32</code>),
and vice versa.
</div>

<p>
Please read <a href="string.html#conversions">strings in Go</a> for details and examples.
</p>

<h4>9. slices related conversions</h4>

<div class="well">
Since Go 1.17, a slice may be converted to an array pointer.
In such a conversion, if the length of the base array type of the pointer type
is larger than the length of the slice, a panic occurs.
</div>

<p>
Here is <a href="container.html#slice-to-array-pointer">an example</a>.
</p>

<div class="well">
Since Go 1.20, a slice may be converted to an array.
In such a conversion, if the length of the array type
is larger than the length of the slice, a panic occurs.
</div>

<p>
Here is <a href="container.html#slice-to-array">an example</a>.
</p>

<h4>10. unsafe pointers related conversion rules</h4>

<div class="well">
A pointer value of any type can be explicitly converted to a type whose underlying type is <code>unsafe.Pointer</code>, and vice versa.
</div>

<div class="well">
An uintptr value can be explicitly converted to a type whose underlying type is <code>unsafe.Pointer</code>, and vice versa.
</div>

<p>
Please read <a href="unsafe.html">type-unsafe pointers in Go</a> for details and examples.
</p>

<h3>Value Assignment Rules</h3>

<p>
Assignments can be viewed as implicit conversions.
Implicit conversion rules are listed among all conversion rules in the last section.
</p>

<p>
Besides these rules, the destination values in assignments must be
addressable values, map index expressions, or the blank identifier.
</p>

<!--
<div class="well">
In an assignment, if the target value is a new declared variable without given a
type in code, then the type of the new variable is
<ul>
<li>the type of the source value, if the source value is a typed value;</li>
<li>the default type of the source value, if the source value is an untyped constant.</li>
</ul>
</div>

<p>
</p>
-->

<p>
In an assignment, the source value is copied to the destination value.
Precisely speaking, the <a href="value-part.html">direct part</a>
of the source value is copied to the destination value.
</p>

<p>
Note, parameter passing and result returning are both value assignments actually.
</p>

<!--
<p>
For most value assignments, the <a href="value-part.html">direct part</a>
of each source value is copied to the direct part of the corresponding
destination value, except that destination value is an interface value.
</p>

<p>
In an assignment, if the destination value is an interface value but
the source value is not, then (the direct part of) the source value
will be copied and the copy result will be stored in
the destination interface value as dynamic value.
The standard compiler makes some special treatments here
if the source value is not a pointer value.
If the source value is not a pointer value,
the direct part of the source value
will be copied and a pointer to the (hidden and immutable) copy
will be stored in the destination interface value.
</p>

<p>
In an assignment,
if both the destination and source values are interface values,
then (the direct part of) the dynamic value of the source interface value
will be copied and the copy result will be stored in
the destination interface value as dynamic value.
The standard compiler makes some optimizations here so that
a pointer is always copied in the process.
</p>
-->

<a class="anchor" id="comparison-rules"></a>
<h3>Value Comparison Rules</h3>

<div>

<p>
Go specification
<a href="https://golang.org/ref/spec#Comparison_operators">states</a>:
</p>

<div class="alert alert-success">
In any comparison, the first operand must be assignable to the type of the second operand, or vice versa.
</div>

<p>
So, the comparison rule is much like the assignment rule.
In other words, two values are comparable if one of them can be implicitly converted to the type of the other.
Right? Almost, for there is another rule which has a higher priority than the above basic comparison rule.
</p>

<!--
https://github.com/golang/go/issues/28164#issuecomment-430733364
-->
<div class="alert alert-danger">
If both of the two operands in a comparison are typed, then their types must be a
<a href="type-system-overview.html#types-not-support-comparison">comparable type</a>.
</div>

<p>
By the above rule, if an incomparable type (which must be a non-interface type) implements an interface type,
then it is illegal to compare values of the two types, even if values of the
former (non-interface) type can be implicitly converted the latter (interface) type.
</p>

<p>
Note, although values of slice/map/function types don't support comparisons,
they can be compared with untyped nil values (a.k.a., bare <code>nil</code> identifiers).
</p>

The above described basic rules don't cover all cases.
What about if both of the two operands in a comparison are untyped (constant) values?
The additional rules are simple:
<ul>
<li>
	untyped boolean values can be compared with untyped boolean values.
</li>
<li>
	untyped numeric values can be compared with untyped numeric values.
</li>
<li>
	untyped string values can be compared with untyped string values.
</li>
</ul>

<p>
The results of comparing two untyped numeric values obey intuition.
</p>

<p>
Note, an untyped nil value can't be compared with another untyped nil value.
</p>

<p>
Any comparison results in an untyped boolean value.
</p>

The following example shows some incomparable types related comparisons.

<pre class="line-numbers"><code class="language-go">package main

// Some variables of incomparable types.
var s []int
var m map[int]int
var f func()()
var t struct {x []int}
var a [5]map[int]int

func main() {
	// The following lines fail to compile.
	/*
	_ = s == s
	_ = m == m
	_ = f == f
	_ = t == t
	_ = a == a
	_ = nil == nil
	_ = s == interface{}(nil)
	_ = m == interface{}(nil)
	_ = f == interface{}(nil)
	*/

	// The following lines compile okay.
	_ = s == nil
	_ = m == nil
	_ = f == nil
	_ = 123 == interface{}(nil)
	_ = true == interface{}(nil)
	_ = "abc" == interface{}(nil)
}
</code></pre>

<p>
</p>

</div>

<a class="anchor" id="comparison-implementation"></a>
<h4>How Are Two Values Compared?</h4>

<div>
Assume two values are comparable, and they have the same type <code>T</code>.
(If they have different types, one of them must be implicitly convertible to the type of the other.
Here we don't consider the cases in which both the two values are untyped.)
<ol>
<li>
	If <code>T</code> is a boolean type,
	then the two values are equal only if they are both <code>true</code> or both <code>false</code>.
</li>
<li>
	If <code>T</code> is an integer type,
	then the two values are equal only if they have the same representation in memory.
</li>
<li>
	If <code>T</code> is a floating-point type,
	then the two values are equal only if any of the following conditions is satisfied:
	<ul>
	<li>
		they are both <code>+Inf</code>.
	</li>
	<li>
		they are both <code>-Inf</code>.
	</li>
	<li>
		each of them is either <code>-0.0</code> or <code>+0.0</code>.
	</li>
	<li>
		they are both not <code>NaN</code> and they have the same bytes representations in memory.
	</li>
	</ul>
</li>
<li>
	If <code>T</code> is a complex type,
	then the two values are equal only if their real parts (as floating-point values)
	and imaginary parts (as floating-point values) are both equal.
</li>
<li>
	If <code>T</code> is a pointer type (either safe or unsafe),
	then the two values are equal only if the memory addresses stored in them are equal.
</li>
<li>
	If <code>T</code> is a channel type, the two channel values are equal
	if they both reference the same underlying internal channel structure value
	or they are both nil channels.
</li>
<li>
	If <code>T</code> is a struct type, then
	<a href="struct.html#comparison">each pair of the corresponding
	fields of the two struct values will be compared</a>.
</li>
<li>
	If <code>T</code> is an array type, then
	<a href="container.html#comparison">each pair of the corresponding
	elements of the two array values will be compared</a>.
</li>
<li>
	If <code>T</code> is an interface type, please read
	<a href="interface.html#comparison">how two interface values are compared</a>.
</li>
<li>
	If <code>T</code> is a string type, please read
	<a href="string.html#comparison">how two string values are compared</a>.
</li>
</ol>

Please note, comparing two interfaces with the same incomparable dynamic type
produces a panic.
The following is an example in which some panics will occur in comparisons.

<pre class="line-numbers"><code class="language-go">package main

func main() {
	type T struct {
		a interface{}
		b int
	}
	var x interface{} = []int{}
	var y = T{a: x}
	var z = [3]T{{a: y}}

	// Each of the following line can produce a panic.
	_ = x == x
	_ = y == y
	_ = z == z
}
</code></pre>

<p>
</p>
</div>


<hr>

<div class="text-center"><a href="#i-value-conversions-assignments-and-comparisons.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><b class="index" id="i-value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</b></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












