<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>nils in Go -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1><code>nil</code>s in Go</h1>



<p>
<code>nil</code> is a frequently used and important predeclared identifier in Go.
It is the literal representation of zero values of many kinds of types.
Many new Go programmers with experiences of some other popular languages
may view <code>nil</code> as the counterpart of
<code>null</code> (or <code>NULL</code>) in other languages.
This is partly right, but there are many differences between <code>nil</code>
in Go and <code>null</code> (or <code>NULL</code>) in other languages.
</p>

<p>
The remaining of this article will list all kinds of facts and details related to <code>nil</code>.
</p>

<h3><code>nil</code> Is a Predeclared Identifier in Go</h3>

<p>
We can use <code>nil</code> without declaring it.
</p>

<h3><code>nil</code> Can Represent Zero Values of Many Types</h3>

<div>
In Go, <code>nil</code> can represent zero values of the following kinds of types:
<ul>
<li>pointer types (including type-unsafe ones).</li>
<li>map types.</li>
<li>slice types.</li>
<li>function types.</li>
<li>channel types.</li>
<li>interface types.</li>
</ul>

</div>

<h3>Predeclared <code>nil</code> Has Not a Default Type</h3>

<div>

Each of other predeclared identifiers in Go has a default type.
For example,
<ul>
<li>
	the default types of <code>true</code> and <code>false</code>
	are both <code>bool</code> type.
</li>
<li>
	the default type of <code>iota</code> is <code>int</code>.
</li>
</ul>

<p>
But the predeclared <code>nil</code> has not a default type, though it has many possible types.
In fact, the predeclared <code>nil</code> is the only untyped value who has not a default type in Go.
There must be sufficient information for compiler to deduce the type of a <code>nil</code> from context.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// There must be sufficient information for
	// compiler to deduce the type of a nil value.
	_ = (*struct{})(nil)
	_ = []int(nil)
	_ = map[int]bool(nil)
	_ = chan string(nil)
	_ = (func())(nil)
	_ = interface{}(nil)

	// These lines are equivalent to the above lines.
	var _ *struct{} = nil
	var _ []int = nil
	var _ map[int]bool = nil
	var _ chan string = nil
	var _ func() = nil
	var _ interface{} = nil

	// This following line doesn't compile.
	var _ = nil
}
</code></pre>
</div>

<h3>Predeclared <code>nil</code> Is Not a Keyword in Go</h3>

<div>
<p>
The predeclared <code>nil</code> can be shadowed.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	nil := 123
	fmt.Println(nil) // 123

	// The following line fails to compile,
	// for nil represents an int value now
	// in this scope.
	var _ map[string]int = nil
}
</code></pre>

<p><i>
(BTW, <code>null</code> and <code>NULL</code> in many other languages
are also not keywords.)
</i></p>
</div>

<a class="anchor" id="sizes"></a>
<h3>The Sizes of Nil Values With Types of Different Kinds May Be Different</h3>

<div>
<p>
The memory layouts of all values of a type are always the same.
nil values of the type are not exceptions
(assume the zero values of the type can be represented as <code>nil</code>).
The size of a nil value is always the same as
the sizes of non-nil values whose types are the same as the nil value.
But nil values of different kinds of types may have different sizes.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"unsafe"
)

func main() {
	var p *struct{} = nil
	fmt.Println( unsafe.Sizeof( p ) ) // 8

	var s []int = nil
	fmt.Println( unsafe.Sizeof( s ) ) // 24

	var m map[int]bool = nil
	fmt.Println( unsafe.Sizeof( m ) ) // 8

	var c chan string = nil
	fmt.Println( unsafe.Sizeof( c ) ) // 8

	var f func() = nil
	fmt.Println( unsafe.Sizeof( f ) ) // 8

	var i interface{} = nil
	fmt.Println( unsafe.Sizeof( i ) ) // 16
}
</code></pre>

<p>
</p>

<p>
The sizes are compiler and architecture dependent.
The above printed results are for 64-bit architectures and the standard Go compiler.
For 32-bit architectures, the printed sizes will be half.
</p>

<p>
For the standard Go compiler, the sizes of two values of different types
of the same kind whose zero values can be represented as the predeclared <code>nil</code>
are always the same. For example, the sizes of all values of all different slice types are the same.
</p>
</div>

<h3>Two Nil Values of Two Different Types May Be Not Comparable</h3>

<div>
For example, the two comparisons in the following example both fail to compile.
The reason is, in each comparison,
neither operand can be implicitly converted to the type of the other.
<pre class="line-numbers"><code class="language-go">// Compilation failure reason: mismatched types.
var _ = (*int)(nil) == (*bool)(nil)         // error
var _ = (chan int)(nil) == (chan bool)(nil) // error
</code></pre>

<p>
</p>

<p>
Please read <a href="value-conversions-assignments-and-comparisons.html#comparison-rules">comparison rules in Go</a>
to get which two values can be compared with each other.
Typed <code>nil</code> values are not exceptions of the comparison rules.
</p>

The code lines in the following example all compile okay.
<pre class="line-numbers"><code class="language-go">type IntPtr *int
// The underlying of type IntPtr is *int.
var _ = IntPtr(nil) == (*int)(nil)

// Every type in Go implements interface{} type.
var _ = (interface{})(nil) == (*int)(nil)

// Values of a directional channel type can be
// converted to the bidirectional channel type
// which has the same element type.
var _ = (chan int)(nil) == (chan<- int)(nil)
var _ = (chan int)(nil) == (<-chan int)(nil)
</code></pre>
</div>

<h3>Two Nil Values of the Same Type May Be Not Comparable</h3>

<div>
In Go, map, slice and function types don't support comparison.
Comparing two values, including nil values, of an incomparable types is illegal.
The following comparisons fail to compile.
<pre class="line-numbers"><code class="language-go">var _ = ([]int)(nil) == ([]int)(nil)
var _ = (map[string]int)(nil) == (map[string]int)(nil)
var _ = (func())(nil) == (func())(nil)
</code></pre>

But any values of the above mentioned incomparable types can
be compared with the bare <code>nil</code> identifier.
<pre class="line-numbers"><code class="language-go">// The following lines compile okay.
var _ = ([]int)(nil) == nil
var _ = (map[string]int)(nil) == nil
var _ = (func())(nil) == nil
</code></pre>
</div>

<h3>Two Nil Values May Be Not Equal</h3>

<div>
<p>
If one of the two compared nil values is an interface value
and the other is not, assume they are comparable,
then the comparison result is always <code>false</code>.
The reason is the non-interface value will be
<a href="interface.html#boxing">converted to the type of the interface value</a>
before making the comparison.
The converted interface value has a dynamic type
but the other interface value has not.
That is why the comparison result is always <code>false</code>.
</p>

Example:
<pre class="disable-line-numbers111"><code class="language-go">fmt.Println( (interface{})(nil) == (*int)(nil) ) // false
</code></pre>
</div>

<h3>Retrieving Elements From Nil Maps Will Not Panic</h3>

<div>
<p>
Retrieving element from a nil map value will always return
a zero element value.
</p>

For example:
<pre class="line-numbers"><code class="language-go">fmt.Println( (map[string]int)(nil)["key"] ) // 0
fmt.Println( (map[int]bool)(nil)[123] )     // false
fmt.Println( (map[int]*int64)(nil)[123] )   // <nil>
</code></pre>
</div>

<h3>It Is Legal to Range Over Nil Channels, Maps, Slices, and Array Pointers</h3>

<div>
<p>
The number of loop steps by iterate nil maps and slices is zero.
</p>

<p>
The number of loop steps by iterate a nil array pointer
is the length of its corresponding array type.
(However, if the length of the corresponding array type is not zero,
and the second iteration is neither ignored nor omitted,
the iteration will panic at run time.)
</p>

<p>
Ranging over a nil channel will block the current goroutine for ever.
</p>

For example, the following code will print <code>0</code>, <code>1</code>,
<code>2</code>, <code>3</code> and <code>4</code>, then block for ever.
<code>Hello</code>, <code>world</code> and <code>Bye</code> will never be printed.
<pre class="line-numbers"><code class="language-go">for range []int(nil) {
	fmt.Println("Hello")
}

for range map[string]string(nil) {
	fmt.Println("world")
}

for i := range (*[5]int)(nil) {
	fmt.Println(i)
}

for range chan bool(nil) { // block here
	fmt.Println("Bye")
}
</code></pre>
</div>

<h3>Invoking Methods Through Non-Interface Nil Receiver Arguments Will Not Panic</h3>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

type Slice []bool

func (s Slice) Length() int {
	return len(s)
}

func (s Slice) Modify(i int, x bool) {
	s[i] = x // panic if s is nil
}

func (p *Slice) DoNothing() {
}

func (p *Slice) Append(x bool) {
	*p = append(*p, x) // panic if p is nil
}

func main() {
	// The following selectors will not cause panics.
	_ = ((Slice)(nil)).Length
	_ = ((Slice)(nil)).Modify
	_ = ((*Slice)(nil)).DoNothing
	_ = ((*Slice)(nil)).Append

	// The following two lines will also not panic.
	_ = ((Slice)(nil)).Length()
	((*Slice)(nil)).DoNothing()

	// The following two lines will panic. But panics
	// will not be triggered at the time of invoking
	// the methods. They will be triggered on
	// dereferencing nil pointers in the method bodies.
	/*
	((Slice)(nil)).Modify(0, true)
	((*Slice)(nil)).Append(true)
	*/
}
</code></pre>

<p>
</p>

In fact, the above implementation of the <code>Append</code> method
is not perfect, it should be modified as the following one.

<pre class="line-numbers"><code class="language-go">func (p *Slice) Append(x bool) {
	if p == nil {
		*p = []bool{x}
		return
	}
	*p = append(*p, x)
}
</code></pre>

<p>
</p>

</div>

<h3><code>*new(T)</code> Results a Nil <code>T</code> Value if the Zero Value of Type <code>T</code> Is Represented With the Predeclared <code>nil</code> Identifier</h3>

<div>
Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	fmt.Println(*new(*int) == nil)         // true
	fmt.Println(*new([]int) == nil)        // true
	fmt.Println(*new(map[int]bool) == nil) // true
	fmt.Println(*new(chan string) == nil)  // true
	fmt.Println(*new(func()) == nil)       // true
	fmt.Println(*new(interface{}) == nil)  // true
}
</code></pre>
</div>

<h3>Summary</h3>

<p>
In Go, for simplicity and convenience,
<code>nil</code> is designed as an identifier which can be used to represent the zero values of some kinds of types.
It is not a single value. It can represent many values with different memory layouts.
</p>
<hr>

<div class="text-center"><a href="#i-nil.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><b class="index" id="i-nil.html">Go의 <code>nil</code></b></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












