<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Common Concurrent Programming Mistakes -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Common Concurrent Programming Mistakes</h1>



<p>
Go is a language supporting built-in concurrent programming.
By using the <code>go</code> keyword to create goroutines (light weight threads)
and by <a href="channel-use-cases.html">using</a>
<a href="channel.html">channels</a> and
<a href="concurrent-atomic-operation.html">other concurrency</a>
<a href="concurrent-synchronization-more.html">synchronization techniques</a>
provided in Go, concurrent programming becomes easy, flexible and enjoyable.
</p>

<p>
One the other hand, Go doesn't prevent Go programmers from making some
concurrent programming mistakes which are caused by either carelessness
or lacking of experience.
The remaining of the current article will show some common mistakes
in Go concurrent programming, to help Go programmers avoid making such mistakes.
</p>

<h3>No Synchronizations When Synchronizations Are Needed</h3>

<div>
<p>
Code lines might be <a href="memory-model.html">not executed by their appearance order</a>.
</p>

There are two mistakes in the following program.
<ul>
<li>
	First, the read of <code>b</code> in the main goroutine and the write
	of <code>b</code> in the new goroutine might cause data races.
</li>
<li>
	Second, the condition <code>b == true</code> can't ensure
	that <code>a != nil</code> in the main goroutine.
	Compilers and CPUs may make optimizations by
	<a href="memory-model.html">reordering instructions</a>
	in the new goroutine, so the assignment of <code>b</code> may happen
	before the assignment of <code>a</code> at run time,
	which makes that slice <code>a</code> is still <code>nil</code>
	when the elements of <code>a</code> are modified in the main goroutine.
</li>
</ul>

<pre class="line-numbers"><code class="language-go">package main

import (
	"time"
	"runtime"
)

func main() {
	var a []int // nil
	var b bool  // false

	// a new goroutine
	go func () {
		a = make([]int, 3)
		b = true // write b
	}()

	for !b { // read b
		time.Sleep(time.Second)
		runtime.Gosched()
	}
	a[0], a[1], a[2] = 0, 1, 2 // might panic
}
</code></pre>

<p>
The above program may run well on one computer, but may panic on another one,
or it runs well when it is compiled by one compiler, but panics when another compiler is used.
</p>

We should use channels or the synchronization techniques provided in
the <code>sync</code> standard package to ensure the memory orders.
For example,

<pre class="line-numbers"><code class="language-go">package main

func main() {
	var a []int = nil
	c := make(chan struct{})

	go func () {
		a = make([]int, 3)
		c <- struct{}{}
	}()

	<-c
	// The next line will not panic for sure.
	a[0], a[1], a[2] = 0, 1, 2
}
</code></pre>

<p>
</p>
</div>

<a class="anchor" id="sleep"></a>
<h3>Use <code>time.Sleep</code> Calls to Do Synchronizations</h3>

<div>

Let's view a simple example.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
)

func main() {
	var x = 123

	go func() {
		x = 789 // write x
	}()

	time.Sleep(time.Second)
	fmt.Println(x) // read x
}
</code></pre>

<p>
We expect this program to print <code>789</code>.
In fact, it really prints <code>789</code>, almost always, in running.
But is it a program with good synchronization?
No! The reason is Go runtime doesn't guarantee the write of <code>x</code>
happens before the read of <code>x</code> for sure.
Under certain conditions, such as most CPU resources are consumed by
some other computation-intensive programs running on the same OS,
the write of <code>x</code> might happen after the read of <code>x</code>.
This is why we should never use <code>time.Sleep</code> calls to do
synchronizations in formal projects.
</p>

<!--
https://groups.google.com/forum/#!topic/golang-nuts/J3kXXZivlHA
-->

Let's view another example.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
)

var x = 0

func main() {
	var num = 123
	var p = &num

	c := make(chan int)

	go func() {
		c <- *p + x
	}()

	time.Sleep(time.Second)
	num = 789
	fmt.Println(<-c)
}
</code></pre>

<p>
What do you expect the program will output? <code>123</code>, or <code>789</code>?
In fact, the output is compiler dependent.
For the standard Go compiler 1.19,
it is very possible the program will output <code>123</code>.
But in theory, it might also output <code>789</code>.
</p>

<p>
Now, let's change <code>c &lt;- *p + x</code> to <code>c &lt;- *p</code>
and run the program again, you will find the output becomes to <code>789</code>
(for the standard Go compiler 1.19).
Again, the output is compiler dependent.
</p>

<p>
Yes, there are data races in the above program.
The expression <code>*p</code> might be evaluated before, after, or when
the assignment <code>num = 789</code> is processed.
The <code>time.Sleep</code> call can't guarantee the evaluation of
<code>*p</code> happens before the assignment is processed.
</p>

For this specified example,
we should store the value to be sent in a temporary value
before creating the new goroutine and send the temporary value instead
in the new goroutine to remove the data races.

<pre class="line-numbers"><code class="language-go">...
	tmp := *p
	go func() {
		c <- tmp
	}()
...
</code></pre>

<p>
</p>

</div>

<h3>Leave Goroutines Hanging</h3>

<div>
Hanging goroutines are the goroutines staying in blocking state for ever.
There are many reasons leading goroutines into hanging. For example,
<ul>
<li>
	a goroutine tries to receive a value from a channel which no more other goroutines will send values to.
</li>
<li>
	a goroutine tries to send a value to nil channel or
	to a channel which no more other goroutines will receive values from.
</li>
<li>
	a goroutine is dead locked by itself.
</li>
<li>
	a group of goroutines are dead locked by each other.
</li>
<li>
	a goroutine is blocked when executing a <code>select</code> code block
	without <code>default</code> branch, and all the channel operations
	following the <code>case</code> keywords in the <code>select</code>
	code block keep blocking for ever.
</li>
</ul>

<p>
Except sometimes we deliberately let the main goroutine in a program hanging
to avoid the program exiting, most other hanging goroutine cases are unexpected.
It is hard for Go runtime to judge whether or not a goroutine
in blocking state is hanging or stays in blocking state temporarily,
so Go runtime will never release the resources consumed by a hanging goroutine.
</p>

In the <a href="channel-use-cases.html#first-response-wins">first-response-wins</a>
channel use case, if the capacity of the channel which is used a future
is not large enough, some slower response goroutines will hang
when trying to send a result to the future channel.
For example, if the following function is called,
there will be 4 goroutines stay in blocking state for ever.

<pre class="line-numbers"><code class="language-go">func request() int {
	c := make(chan int)
	for i := 0; i < 5; i++ {
		i := i
		go func() {
			c <- i // 4 goroutines will hang here.
		}()
	}
	return <-c
}
</code></pre>

<p>
To avoid the four goroutines hanging, the capacity of channel <code>c</code>
must be at least <code>4</code>.
</p>

In <a href="channel-use-cases.html#first-response-wins-2">the second way
to implement the first-response-wins</a> channel use case,
if the channel which is used as a future/promise is an unbuffered channel,
like the following code shows,
it is possible that the channel receiver will miss all responses and hang.

<pre class="line-numbers"><code class="language-go">func request() int {
	c := make(chan int)
	for i := 0; i < 5; i++ {
		i := i
		go func() {
			select {
			case c <- i:
			default:
			}
		}()
	}
	return <-c // might hang here
}
</code></pre>

<p>
The reason why the receiver goroutine might hang is that if the five try-send operations
all happen before the receive operation <code>&lt;-c</code> is ready,
then all the five try-send operations will fail to send values
so that the caller goroutine will never receive a value.
</p>

<p>
Changing the channel <code>c</code> as a buffered channel will guarantee
at least one of the five try-send operations succeed so that the caller
goroutine will never hang in the above function.
</p>

</div>

<h3>Copy Values of the Types in the <code>sync</code> Standard Package</h3>

<div>
<p>
In practice, values of the types (except the <code>Locker</code> interface values)
in the <code>sync</code> standard package should never be copied.
We should only copy pointers of such values.
</p>

The following is bad concurrent programming example.
In this example, when the <code>Counter.Value</code> method is called,
a <code>Counter</code> receiver value will be copied.
As a field of the receiver value, the respective <code>Mutex</code> field
of the <code>Counter</code> receiver value will also be copied.
The copy is not synchronized, so the copied  <code>Mutex</code> value might be corrupted.
Even if it is not corrupted, what it protects is the use of
the copied field <code>n</code>, which is meaningless generally.

<pre class="line-numbers"><code class="language-go">import "sync"

type Counter struct {
	sync.Mutex
	n int64
}

// This method is okay.
func (c *Counter) Increase(d int64) (r int64) {
	c.Lock()
	c.n += d
	r = c.n
	c.Unlock()
	return
}

// The method is bad. When it is called,
// the Counter receiver value will be copied.
func (c Counter) Value() (r int64) {
	c.Lock()
	r = c.n
	c.Unlock()
	return
}
</code></pre>

<p>
We should change the receiver type of the <code>Value</code> method to
the pointer type <code>*Counter</code> to avoid copying <code>sync.Mutex</code> values.
</p>

<p>
The <code>go vet</code> command provided in Go Toolchain will report
potential bad value copies.
</p>

</div>

<h3>Call the <code>sync.WaitGroup.Add</code> Method at Wrong Places</h3>

<div>

<p>
Each <code>sync.WaitGroup</code> value maintains a counter internally,
The initial value of the counter is zero.
If the counter of a <code>WaitGroup</code> value is zero,
a call to the <code>Wait</code> method of the <code>WaitGroup</code> value
will not block, otherwise, the call blocks until the counter value becomes zero.
</p>

<p>
To make the uses of <code>WaitGroup</code> value meaningful,
when the counter of a <code>WaitGroup</code> value is zero,
the next call to the <code>Add</code> method of the <code>WaitGroup</code> value
must happen before the next call to the <code>Wait</code> method of
the <code>WaitGroup</code> value.
</p>

For example, in the following program, the <code>Add</code> method
is called at an improper place, which makes that the final printed number
is not always <code>100</code>. In fact, the final printed number of
the program may be an arbitrary number in the range <code>[0, 100)</code>.
The reason is none of the <code>Add</code> method calls are guaranteed to
happen before the <code>Wait</code> method call, which causes none of
the <code>Done</code> method calls are guaranteed to
happen before the <code>Wait</code> method call returns.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

func main() {
	var wg sync.WaitGroup
	var x int32 = 0
	for i := 0; i < 100; i++ {
		go func() {
			wg.Add(1)
			atomic.AddInt32(&x, 1)
			wg.Done()
		}()
	}

	fmt.Println("Wait ...")
	wg.Wait()
	fmt.Println(atomic.LoadInt32(&x))
}
</code></pre>

<p>
</p>

To make the program behave as expected, we should move the <code>Add</code>
method calls out of the new goroutines created in the <code>for</code> loop,
as the following code shown.

<pre class="line-numbers"><code class="language-go">...
	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			atomic.AddInt32(&x, 1)
			wg.Done()
		}()
	}
...
</code></pre>

<p>
</p>

</div>

<h3>Use Channels as Futures/Promises Improperly</h3>

<div>

From the article <a href="channel-use-cases.html">channel use cases</a>,
we know that some functions will return
<a href="channel-use-cases.html#future-promise">channels as futures</a>.
Assume <code>fa</code> and <code>fb</code> are two such functions,
then the following call uses future arguments improperly.

<pre class="line-numbers"><code class="language-go">doSomethingWithFutureArguments(<-fa(), <-fb())
</code></pre>

<p>
In the above code line, the generations of the two arguments are processed sequentially, instead of concurrently.
</p>

We should modify it as the following to process them concurrently.

<pre class="line-numbers"><code class="language-go">ca, cb := fa(), fb()
doSomethingWithFutureArguments(<-ca, <-cb)
</code></pre>

<p>
</p>

</div>

<h3>Close Channels Not From the Last Active Sender Goroutine</h3>

<div>

<p>
A common mistake made by Go programmers is closing a channel when there are
still some other goroutines will potentially send values to the channel later.
When such a potential send (to the closed channel) really happens,
a panic might occur.
</p>

<p>
This mistake was ever made in some famous Go projects, such as
<a href="https://github.com/kubernetes/kubernetes/pull/45291/files?diff=split">this bug</a>
and
<a href="https://github.com/kubernetes/kubernetes/pull/39479/files?diff=split">this bug</a>
in the kubernetes project.
</p>

<p>
Please read <a href="channel-closing.html">this article</a> for explanations
on how to safely and gracefully close channels.
</p>

</div>


<h3>Do 64-bit Atomic Operations on Values Which Are Not Guaranteed to Be 8-byte Aligned</h3>

<div>
<p>
The address of the value involved in a non-method 64-bit atomic operation is required to be 8-byte aligned.
Failure to do so may make the current goroutine panic.
For the standard Go compiler, such failure can only
<a href="https://golang.org/pkg/sync/atomic/#pkg-note-BUG">happen on 32-bit architectures</a>.
Since Go 1.19, we can use 64-bit method atomic operations to avoid the drawback.
Please read <a href="memory-layout.html">memory layouts</a> to get how to
guarantee the addresses of 64-bit word 8-byte aligned on 32-bit OSes.
</p>

</div>

<h3>Not Pay Attention to Too Many Resources Are Consumed by Calls to the <code>time.After</code> Function</h3>

<div>
<p>
The <code>After</code> function in the <code>time</code> standard package
returns <a href="channel-use-cases.html#timer">a channel for delay notification</a>.
The function is convenient, however each of its calls will
create a new value of the <code>time.Timer</code> type.
The new created <code>Timer</code> value will keep alive in the duration
specified by the passed argument to the <code>After</code> function.
If the function is called many times in a certain period,
there will be many alive <code>Timer</code> values accumulated
so that much memory and computation is consumed.
</p>

For example, if the following <code>longRunning</code> function is called
and there are millions of messages coming in one minute, then there will
be millions of <code>Timer</code> values alive in a certain small period (several seconds),
even if most of these <code>Timer</code> values have already become useless.

<pre class="line-numbers"><code class="language-go">import (
	"fmt"
	"time"
)

// The function will return if a message
// arrival interval is larger than one minute.
func longRunning(messages <-chan string) {
	for {
		select {
		case <-time.After(time.Minute):
			return
		case msg := <-messages:
			fmt.Println(msg)
		}
	}
}
</code></pre>

<p>
</p>

To avoid too many <code>Timer</code> values being created in the above code,
we should use (and reuse) a single <code>Timer</code> value to do the same job.

<pre class="line-numbers"><code class="language-go">func longRunning(messages <-chan string) {
	timer := time.NewTimer(time.Minute)
	defer timer.Stop()

	for {
		select {
		case <-timer.C: // expires (timeout)
			return
		case msg := <-messages:
			fmt.Println(msg)

			// This "if" block is important.
			if !timer.Stop() {
				<-timer.C
			}
		}

		// Reset to reuse.
		timer.Reset(time.Minute)
	}
}
</code></pre>

<p>
Note, the <code>if</code> code block is used to discard/drain a possible timer notification
which is sent in the small period when executing the second branch code block.
</p>

</div>

<h3>Use <code>time.Timer</code> Values Incorrectly</h3>

<div>

An idiomatic use example of <code>time.Timer</code> values has been shown in the last section.
Some explanations:
<ul>
<li>
	the <code>Stop</code> method of a <code>*Timer</code> value returns <code>false</code>
	if the corresponding <code>Timer</code> value has already expired or been stopped.
	If the <code>Stop</code> method returns <code>false</code>, and we know
	the <code>Timer</code> value has not been stopped yet,
	then the <code>Timer</code> value must have already expired.
</li>
<li>
	after a <code>Timer</code> value is stopped, its <code>C</code> channel field
	can only contain most one timeout notification.
</li>
<li>
	we should take out the timeout notification, if it hasn't been taken out,
	from a timeout <code>Timer</code> value after the <code>Timer</code> value is stopped
	and before resetting and reusing the <code>Timer</code> value.
	This is the meaningfulness of the <code>if</code> code block in the example in the last section.
</li>
</ul>

<p>
The <code>Reset</code> method of a <code>*Timer</code> value must be called
when the corresponding <code>Timer</code> value has already expired or been stopped, otherwise,
a data race may occur between the <code>Reset</code> call and
a possible notification send to the <code>C</code> channel field of the <code>Timer</code> value.
</p>

<p>
If the first <code>case</code> branch of the <code>select</code> block is selected,
it means the <code>Timer</code> value has already expired, so we don't need to stop it,
for the sent notification has already been taken out.
However, we must stop the timer in the second branch to check whether or not a timeout notification exists.
If it does exist, we should drain it before reusing the timer,
otherwise, the notification will be fired immediately in the next loop step.
</p>

For example, the following program is very possible to exit in about one second,
instead of ten seconds. And more importantly, the program is not data race free.

<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
)

func main() {
	start := time.Now()
	timer := time.NewTimer(time.Second/2)
	select {
	case <-timer.C:
	default:
		// Most likely go here.
		time.Sleep(time.Second)
	}
	// Potential data race in the next line.
	timer.Reset(time.Second * 10)
	<-timer.C
	fmt.Println(time.Since(start)) // about 1s
}
</code></pre>

<p>
A <code>time.Timer</code> value can be leaved in non-stopping status
when it is not used any more, but it is recommended to stop it in the end.
</p>

<p>
It is bug prone and not recommended to use a <code>time.Timer</code> value
concurrently among multiple goroutines.
</p>

<p>
We should not rely on the return value of a <code>Reset</code> method call.
The return result of the <code>Reset</code> method exists
just for compatibility purpose.
</p>
</div>

<!--
go concurrency programming mistake: hybrid mutex and atomic
Don't mix atomic and non-atomic accesses for a given memory word:
* https://groups.google.com/forum/#!topic/golang-dev/vVkH_9fl1D8

https://github.com/golang/go/issues/34889

-->

<hr>

<div class="text-center"><a href="#i-concurrent-common-mistakes.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><b class="index" id="i-concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</b></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












