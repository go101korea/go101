<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Memory Leaking Scenarios -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Memory Leaking Scenarios</h1>



<p>
When programming in a language supporting auto garbage collection,
generally we don't need care about memory leaking problems,
for the runtime will collect unused memory regularly.
However, we do need to be aware of some special scenarios
which may cause kind-of or real memory leaking.
The remaining of the current article will list several such scenarios.
</p>

<a class="anchor" id="substring"></a>
<h3>Kind-of Memory Leaking Caused by Substrings</h3>

<div>
<p>
Go specification doesn't specify whether or not the result string
and base string involved in a substring expression should share
the same underlying <a href="memory-block.html">memory block</a> to host
<a href="string.html">the underlying byte sequences</a> of the two strings.
The standard Go compiler/runtime does let them share the same underlying memory block.
This is a good design, which is both memory and CPU consuming wise.
But it may cause kind-of memory leaking sometimes.
</p>

For example, after the <code>demo</code> function in the following example is called,
there will be about 1M bytes memory leaking (kind of),
until the package-level variable <code>s0</code> is modified again elsewhere.

<pre class="line-numbers"><code class="language-go">var s0 string // a package-level variable

// A demo purpose function.
func f(s1 string) {
	s0 = s1[:50]
	// Now, s0 shares the same underlying memory block
	// with s1. Although s1 is not alive now, but s0
	// is still alive, so the memory block they share
	// couldn't be collected, though there are only 50
	// bytes used in the block and all other bytes in
	// the block become unavailable.
}

func demo() {
	s := createStringWithLengthOnHeap(1 << 20) // 1M bytes
	f(s)
}
</code></pre>

<p>
</p>

To avoid this kind-of memory leaking, we can convert the substring to a
<code>[]byte</code> value then convert the <code>[]byte</code> value back
to <code>string</code>.

<pre class="line-numbers"><code class="language-go">func f(s1 string) {
	s0 = string([]byte(s1[:50]))
}
</code></pre>

<p>
The drawback of the above way to avoid the kind-of memory leaking
is there are two 50-byte duplicates which happen in the conversion process,
one of them is unnecessary.
</p>

We can make use of one of <a href="string.html#conversion-optimizations">the
optimizations</a> made by the standard Go compiler to avoid the unnecessary duplicate,
with a small extra cost of one byte memory wasting.

<pre class="line-numbers"><code class="language-go">func f(s1 string) {
	s0 = (" " + s1[:50])[1:]
}
</code></pre>

<p>
The disadvantage of the above way is the compiler optimization may become
invalid later, and the optimization may be not available from other compilers.
</p>

The third way to avoid the kind-of memory leaking is to utilize
the <code>strings.Builder</code> supported since Go 1.10.

<pre class="line-numbers"><code class="language-go">import "strings"

func f(s1 string) {
	var b strings.Builder
	b.Grow(50)
	b.WriteString(s1[:50])
	s0 = b.String()
}
</code></pre>

<p>
The disadvantage of the third way is it is a little verbose (by comparing to the first two ways).
A good news is, since Go 1.12,
we can call the <code>Repeat</code> function with the <code>count</code> argument as <code>1</code>
in the <code>strings</code> standard package to clone a string.
Since Go 1.12, the underlying implementation of <code>strings.Repeat</code> will make use of <code>strings.Builder</code>,
to avoid one unnecessary duplicate.
</p>

<p>
Since Go 1.18, a <code>Clone</code> function has been added to the <code>strings</code> standard package.
It becomes the best way to do this job.
</p>

</div>

<a class="anchor" id="subslice"></a>
<h3>Kind-of Memory Leaking Caused by Subslices</h3>

<div>
Similarly to substrings, subslices may also cause kind-of memory leaking.
In the following code, after the <code>g</code> function is called,
most memory occupied by the memory block hosting the elements of <code>s1</code>
will be lost (if no more values reference the memory block).

<pre class="line-numbers"><code class="language-go">var s0 []int

func g(s1 []int) {
	// Assume the length of s1 is much larger than 30.
	s0 = s1[len(s1)-30:]
}
</code></pre>

<p>
</p>

If we want to avoid the kind-of memory leaking, we must duplicate the
30 elements for <code>s0</code>, so that the aliveness of <code>s0</code>
will not prevent the memory block hosting the elements of <code>s1</code>
from being collected.

<pre class="line-numbers"><code class="language-go">func g(s1 []int) {
	s0 = make([]int, 30)
	copy(s0, s1[len(s1)-30:])
	// Now, the memory block hosting the elements
	// of s1 can be collected if no other values
	// are referencing the memory block.
}
</code></pre>

</div>

<a class="anchor" id="dead-slice-elements"></a>
<h3>Kind-of Memory Leaking Caused by Not Resetting Pointers in Lost Slice Elements</h3>

<div>
In the following code, after the <code>h</code> function is called,
the memory block allocated for the first and the last elements of slice
<code>s</code> will get lost.

<pre class="line-numbers"><code class="language-go">func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// do something with s ...

	return s[1:3:3]
}
</code></pre>

<p>
As long as the returned slice is still alive, it will prevent any elements
of <code>s</code> from being collected, which in consequence prevents
the two memory blocks allocated for the two <code>int</code> values
referenced by the first and the last elements of <code>s</code> from being collected.
</p>

If we want to avoid such kind-of memory leaking,
we must reset the pointers stored in the lost elements.

<pre class="line-numbers"><code class="language-go">func h() []*int {
	s := []*int{new(int), new(int), new(int), new(int)}
	// do something with s ...

	// Reset pointer values.
	s[0], s[len(s)-1] = nil, nil
	return s[1:3:3]
}
</code></pre>

<p>
</p>

<p>
We often need to reset the pointers for some old slice elements in
<a href="container.html#slice-manipulations">slice element deletion operations</a>.
</p>

</div>

<a class="anchor" id="hanging-goroutine"></a>
<h3>Real Memory Leaking Caused by Hanging Goroutines</h3>

<div>
<p>
Sometimes, some goroutines in a Go program may stay in blocking state for ever.
Such goroutines are called hanging goroutines.
Go runtime will not kill hanging goroutines, so the resources allocated for
(and the memory blocks referenced by) the hanging goroutines will never get garbage collected.
</p>

<p>
There are two reasons why Go runtime will not kill hanging goroutines.
One is that sometimes it is hard for Go runtime to judge whether or not a blocking goroutine will be blocked for ever.
The other is sometimes we deliberately make a goroutine hanging.
For example, sometimes we may let the main goroutine of a Go program hang to avoid the program exiting.
</p>

<p>
We should avoid hanging goroutines which are caused by some logic mistakes in code design.
</p>

</div>

<h3>Real Memory Leaking Caused by Not Stopping <code>time.Ticker</code> Values Which Are Not Used Any More</h3>

<p>
When a <code>time.Timer</code> value is not used any more,
it will be garbage collected after some time.
But this is not true for a <code>time.Ticker</code> value.
We should stop a <code>time.Ticker</code> value when it is not used any more.
</p>

<h3>Real Memory Leaking Caused by Using Finalizers Improperly</h3>

<div>
<p>
Setting a finalizer for a value which is a member of a cyclic reference group may
<a href="https://golang.org/pkg/runtime/#SetFinalizer">prevent all memory blocks allocated
for the cyclic reference group from being collected</a>.
This is real memory leaking, not kind of.
</p>

For example, after the following function is called and exits,
the memory blocks allocated for <code>x</code> and <code>y</code> are not
guaranteed to be garbage collected in future garbage collecting.

<pre class="line-numbers"><code class="language-go">func memoryLeaking() {
	type T struct {
		v [1<<20]int
		t *T
	}

	var finalizer = func(t *T) {
		 fmt.Println("finalizer called")
	}

	var x, y T

	// The SetFinalizer call makes x escape to heap.
	runtime.SetFinalizer(&x, finalizer)

	// The following line forms a cyclic reference
	// group with two members, x and y.
	// This causes x and y are not collectable.
	x.t, y.t = &y, &x // y also escapes to heap.
}
</code></pre>

<p>
So, please avoid setting finalizers for values in a cyclic reference group.
</p>

<p>
By the way, we <a href="unofficial-faq.html#finalizers">shouldn't use
finalizers as object destructors</a>.
</p>
</div>

<h3>Kind-of Resource Leaking by Deferring Function Calls</h3>

<div>

<p>
Please read <a href="defer-more.html#kind-of-resource-leaking">this article</a> for details.
</p>

</div>


<!--
forgot closing streams

the capacity of the underlying array of a map will never shrink.

defer in infinite/long-period loop
-->

<hr>

<div class="text-center"><a href="#i-memory-leaking.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><b class="index" id="i-memory-leaking.html">메모리 누수 시나리오</b></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












