<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Pointers in Go -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Pointers in Go</h1>



<p>
Although Go absorbs many features from all kinds of other languages,
Go is mainly viewed as a C family language.
One evidence is Go also supports pointers.
Go pointers and C pointers are much similar in many aspects,
but there are also some differences between Go pointers and C pointers.
This article will list all kinds of concepts and details related to pointers in Go.
</p>

<h3>Memory Addresses</h3>

<p>
A memory address means a specific memory location in programming.
</p>

<p>
Generally, a memory address is stored as an unsigned native (integer) word.
The size of a native word is 4 (bytes) on 32-bit architectures and 8 (bytes)
on 64-bit architectures.
So the theoretical maximum memory space size is 2<sup>32</sup> bytes,
a.k.a. 4GB (1GB == 2<sup>30</sup> bytes), on 32-bit architectures,
and is 2<sup>64</sup> bytes a.k.a 16EB (1EB == 1024PB, 1PB == 1024TB, 1TB == 1024GB), on 64-bit architectures.
</p>

<p>
Memory addresses are often represented with hex integer literals,
such as <code>0x1234CDEF</code>.
</p>

<h3>Value Addresses</h3>

<p>
The address of a value means the start address of the memory segment
occupied by the <a href="value-part.html">direct part</a> of the value.
</p>

<h3>What Are Pointers?</h3>

<p>
Pointer is one kind of type in Go.
A pointer value is used to store a memory address,
which is generally the address of another value.
</p>

<p>
Unlike C language, for safety reason, there are some restrictions made for Go pointers.
Please read the following sections for details.
</p>

<h3>Go Pointer Types and Values</h3>

<div>
<p>
In Go, an unnamed pointer type can be represented with <code>*T</code>,
where <code>T</code> can be an arbitrary type.
Type <code>T</code> is called the base type of pointer type <code>*T</code>.
</p>

<p>
We can declare named pointer types, but generally,
it’s not recommended to use named pointer types,
for unnamed pointer types have better readabilities.
</p>

<p>
If the <a href="type-system-overview.html#underlying-type">underlying type</a>
of a named pointer type is <code>*T</code>,
then the base type of the named pointer type is <code>T</code>.
</p>

<p>
Two unnamed pointer types with the same base type are the same type.
</p>

Example:
<pre class="line-numbers"><code class="language-go">*int  // An unnamed pointer type whose base type is int.
**int // An unnamed pointer type whose base type is *int.

// Ptr is a named pointer type whose base type is int.
type Ptr *int
// PP is a named pointer type whose base type is Ptr.
type PP *Ptr
</code></pre>

<p>
</p>

<p>
Zero values of any pointer types are represented with the predeclared <code>nil</code>.
No addresses are stored in nil pointer values.
</p>

<p>
A value of a pointer type whose base type is <code>T</code> can only store the addresses of values of type <code>T</code>.
</p>

</div>

<a class="anchor" id="references"></a>
<h3>About the Word "Reference"</h3>

<p>
In Go 101, the word "reference" indicates a relation.
For example, if a pointer value stores the address of another value,
then we can say the pointer value (directly) references the other value,
and the other value has at least one reference.
The uses of the word "reference" in Go 101 are consistent with Go specification.
</p>

<p>
When a pointer value references another value, we also often say the pointer value points to the other value.
</p>

<h3>How to Get a Pointer Value and What Are Addressable Values?</h3>

<div>
There are two ways to get a non-nil pointer value.
<ol>
<li>
	The built-in <code>new</code> function can be used to allocate memory for a value
	of any type. <code>new(T)</code> will allocate memory for a <code>T</code> value
	(an anonymous variable) and return the address of the <code>T</code> value.
	The allocated value is a zero value of type <code>T</code>.
	The returned address is viewed as a pointer value of type <code>*T</code>.
</li>
<li>
	We can also take the addresses of values which are addressable in Go.
	For an addressable value <code>t</code> of type <code>T</code>,
	we can use the expression <code>&amp;t</code> to take the address of <code>t</code>,
	where <code>&amp;</code> is the operator to take value addresses.
	The type of <code>&amp;t</code> is viewed as <code>*T</code>.
</li>
</ol>
</div>

<p>
Generally speaking, an addressable value means a value which is hosted at somewhere in memory.
Currently, we just need to know that all variables are addressable,
whereas constants, function calls and explicit conversion results are all unaddressable.
When a variable is declared, Go runtime will allocate a piece of memory for the variable.
The starting address of that piece of memory is the address of the variable.
</p>

<p>
We will learn other addressable and unaddressable values from other articles later.
If you have already been familiar with Go, you can read
<a href="summaries.html#not-addressable">this summary</a> to get
the lists of addressable and unaddressable values in Go.
</p>

<p>
The next section will show an example on how to get pointer values.
</p>

<h3>Pointer Dereference</h3>

<p>
Given a pointer value <code>p</code> of a pointer type whose base type is <code>T</code>,
how can you get the value at the address stored in the pointer (a.k.a., the value
being referenced by the pointer)? Just use the expression <code>*p</code>,
where <code>*</code> is called dereference operator.
<code>*p</code> is called the dereference of pointer <code>p</code>.
Pointer dereference is the inverse process of address taking.
The result of <code>*p</code> is a value of type <code>T</code> (the base type of the type of <code>p</code>).
</p>

<p>
Dereferencing a nil pointer causes a runtime panic.
</p>

<div>
The following program shows some address taking
and pointer dereference examples:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	p0 := new(int)   // p0 points to a zero int value.
	fmt.Println(p0)  // (a hex address string)
	fmt.Println(*p0) // 0

	// x is a copy of the value at
	// the address stored in p0.
	x := *p0
	// Both take the address of x.
	// x, *p1 and *p2 represent the same value.
	p1, p2 := &x, &x
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0 // <=> p3 := &(*p0) <=> p3 := p0
	// Now, p3 and p0 store the same address.
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}
</code></pre>

<p>
</p>

<p>
The following picture depicts the relations of the values
used in the above program.
</p>

<div class="text-center">
<img src="res/pointer.png" alt="pointer value"></img>
</div>
</div>

<h3>Why Do We Need Pointers?</h3>

<div>
Let's view an example firstly.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func double(x int) {
	x += x
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}
</code></pre>

<p>
The <code>double</code> function in the above example is expected to modify
the input argument by doubling it. However, it fails. Why?
Because all value assignments, including function argument passing, are value copying in Go.
What the <code>double</code> function modified is a copy (<code>x</code>) of variable <code>a</code> but not variable <code>a</code>.
</p>

One solution to fix the above <code>double</code> function is let it return
the modification result. This solution doesn't always work for all scenarios.
The following example shows another solution, by using a pointer parameter.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func double(x *int) {
	*x += *x
	x = nil // the line is just for explanation purpose
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}
</code></pre>

<p>
We can find that, by changing the parameter to a pointer type,
the passed pointer argument <code>&amp;a</code> and its copy <code>x</code> used in the function body both reference the same value,
so the modification on <code>*x</code> is equivalent to a modification on <code>*p</code>, a.k.a., variable <code>a</code>.
In other words, the modification in the <code>double</code> function body can be reflected out of the function now.
</p>

<p>
Surely, the modification of the copy of the passed pointer argument itself
still can't be reflected on the passed pointer argument.
After the second <code>double</code> function call, the local pointer
<code>p</code> doesn't get modified to <code>nil</code>.
</p>

<p>
In short, pointers provide indirect ways to access some values.
Many languages do not have the concept of pointers.
However, pointers are just hidden under other concepts in those languages.
</p>

</div>

<h3>Return Pointers of Local Variables Is Safe in Go</h3>

<div>
Unlike C language, Go is a language supporting garbage collection,
so return the address of a local variable is absolutely safe in Go.
<pre class="line-numbers"><code class="language-go">func newInt() *int {
	a := 3
	return &a
}
</code></pre>
</div>

<a class="anchor" id="restrictions"></a>
<h3>Restrictions on Pointers in Go</h3>

<p>
For safety reasons, Go makes some restrictions to pointers (comparing to pointers in C language).
By applying these restrictions, Go keeps the benefits of pointers,
and avoids the dangerousness of pointers at the same time.
</p>

<h4>Go pointer values don't support arithmetic operations</h4>

<div>
<p>
In Go, pointers can't do arithmetic operations.
For a pointer <code>p</code>, <code>p++</code> and <code>p-2</code> are both illegal.
</p>

<p>
If <code>p</code> is a pointer to a numeric value, compilers will view
<code>*p++</code> is a legal statement and treat it as <code>(*p)++</code>.
In other words, the precedence of the pointer dereference operator <code>*</code>
is higher than the increment operator <code>++</code> and decrement operator <code>--</code>.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	a := int64(5)
	p := &a

	// The following two lines don't compile.
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	*&a++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10
}
</code></pre>
</div>

<h4>A pointer value can't be converted to an arbitrary pointer type</h4>

<div>
In Go, a pointer value of pointer type <code>T1</code> can be directly and explicitly converted
to another pointer type <code>T2</code> only if either of the following two conditions
is get satisfied.
<ol>
<li>
	The underlying types of type <code>T1</code> and <code>T2</code> are identical (ignoring struct tags),
	in particular if either <code>T1</code> and <code>T2</code> is a
	<a href="type-system-overview.html#named-type">unnamed</a> type
	and their underlying types are identical (considering struct tags),
	then the conversion can be implicit.
	Struct types and values will be explained in
	<a href="struct.html">the next article</a>.
</li>
<li>
	Type <code>T1</code> and <code>T2</code> are both unnamed pointer types and
	the underlying types of their base types are identical (ignoring struct tags).
</li>
</ol>

For example, for the below shown pointer types:
<pre class="line-numbers"><code class="language-go">type MyInt int64
type Ta    *int64
type Tb    *MyInt
</code></pre>

the following facts exist:
<ol>
<li>
	values of type <code>*int64</code> can be implicitly converted to type <code>Ta</code>,
	and vice versa, for their underlying types are both <code>*int64</code>.
</li>
<li>
	values of type <code>*MyInt</code> can be implicitly converted to type <code>Tb</code>,
	and vice versa, for their underlying types are both <code>*MyInt</code>.
</li>
<li>
	values of type <code>*MyInt</code> can be explicitly converted to type <code>*int64</code>,
	and vice versa, for they are both unnamed and the underlying types of their base types are both <code>int64</code>.
</li>
<li>
	values of type <code>Ta</code> can't be directly converted to type <code>Tb</code>, even if explicitly.
	However, by the just listed first three facts, a value <code>pa</code> of
	type <code>Ta</code> can be indirectly converted to type <code>Tb</code>
	by nesting three explicit conversions, <code>Tb((*MyInt)((*int64)(pa)))</code>.
</li>
</ol>

<p>
None values of these pointer types can be converted to type <code>*uint64</code>, in any safe ways.
</p>
</div>

<h4>A pointer value can't be compared with values of an arbitrary pointer type</h4>

<div>
In Go, pointers can be compared with <code>==</code> and <code>!=</code> operators.
Two Go pointer values can only be compared if either of the following three conditions
are satisfied.
<ol>
<li>
	The types of the two Go pointers are identical.
</li>
<li>
	One pointer value can be implicitly converted to the pointer type of the other.
	In other words, the underlying types of the two types must be identical
	and either of the two types of the two Go pointers is an unnamed type.
</li>
<li>
	One and only one of the two pointers is represented with the bare (untyped) <code>nil</code> identifier.
</li>
</ol>

Example:
<pre class="line-numbers"><code class="language-go">package main

func main() {
	type MyInt int64
	type Ta    *int64
	type Tb    *MyInt

	// 4 nil pointers of different types.
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// The following 6 lines all compile okay.
	// The comparison results are all true.
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// None of the following 3 lines compile ok.
	/*
	_ = pa0 == pb0
	_ = pa1 == pb1
	_ = pa0 == Tb(nil)
	*/
}
</code></pre>
<p>
</p>
</div>

<h4>A pointer value can't be assigned to pointer values of other pointer types</h4>

<p>
The conditions to assign a pointer value to another pointer value are the
same as the conditions to compare a pointer value to another pointer value,
which are listed above.
</p>

<h3>It's Possible to Break the Go Pointer Restrictions</h3>

<p>
As the start of this article has mentioned,
the mechanisms (specifically, the <code>unsafe.Pointer</code> type)
provided by <a href="unsafe.html">the <code>unsafe</code> standard package</a>
can be used to break the restrictions made for pointers in Go.
The <code>unsafe.Pointer</code> type is like the <code>void*</code> in C.
In general the unsafe ways are not recommended to use.
</p>




<hr>

<div class="text-center"><a href="#i-pointer.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><b class="index" id="i-pointer.html">포인터</b></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












