<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Basic Control Flows -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Basic Control Flows</h1>



<p>
The control flow code blocks in Go are much like other popular programming languages,
but there are also many differences.
This article will show these similarities and differences.
</p>

<h3>An Introduction of Control Flows in Go</h3>

<div>
There are three kinds of basic control flow code blocks in Go:
<ul>
<li>
	<code>if-else</code> two-way conditional execution block.
</li>
<li>
	<code>for</code> loop block.
</li>
<li>
	<code>switch-case</code> multi-way conditional execution block.
</li>
</ul>

There are also some control flow code blocks which are related to some certain kinds of types in Go.
<ul>
<li>
	<code>for-range</code> loop block for
	<a href="container.html#iteration">container</a> types.
</li>
<li>
	<code>type-switch</code> multi-way conditional execution block for
	<a href="interface.html#type-switch">interface</a> types.
</li>
<li>
	<code>select-case</code> block for
	<a href="channel.html#select">channel</a> types.
</li>
</ul>

<p>
Like many other popular languages, Go also supports <code>break</code>,
<code>continue</code> and <code>goto</code> code execution jump statements.
Besides these, there is a special code jump statement in Go, <code>fallthrough</code>.
</p>

<p>
Among the six kinds of control flow blocks,
except the <code>if-else</code> control flow,
the other five are called <b>breakable control flow blocks</b>.
We can use <code>break</code> statements to make executions
jump out of breakable control flow blocks.
</p>

<p>
<code>for</code> and <code>for-range</code> loop blocks are called
<b>loop control flow blocks</b>.
We can use <code>continue</code> statements to end a loop step in advance
in a loop control flow block, i.e. continue to the next iteration of the loop.
</p>

<p>
Please note, each of the above mentioned control flow blocks is a statement,
and it may contain many other sub-statements.
</p>

<p>
Above mentioned control flow statements are all the ones in narrow sense.
The mechanisms introduced in the next article,
<a href="control-flows-more.html">goroutines, deferred function calls and
panic/recover</a>, and the concurrency synchronization techniques introduced
in the later article
<a href="concurrent-synchronization-overview.html">concurrency synchronization overview</a>
can be viewed as control flow statements in broad sense.
</p>

<p>
Only the basic control flow code blocks and code jump statements will be explained
in the current article, other ones will be explained in
many other Go 101 articles later.
</p>
</div>

<a class="anchor" id="if-else"></a>
<h3><code>if-else</code> Control Flow Blocks</h3>

<div>
The full form of a <code>if-else</code> code block is like
<pre class="line-numbers"><code class="language-go">if InitSimpleStatement; Condition {
	// do something
} else {
	// do something
}
</code></pre>

<p>
<code>if</code> and <code>else</code> are keywords.
Like many other programming languages, the <code>else</code> branch is optional.
</p>

<p>
The <code>InitSimpleStatement</code> portion is also optional.
It must be a <a href="expressions-and-statements.html#simple-statements">simple statement</a> if it is present.
If it is absent, we can view it as a blank statement (one kind of simple statements).
In practice, <code>InitSimpleStatement</code> is often
a short variable declaration or a pure assignment.
A <code>Condition</code> must be an <a href="expressions-and-statements.html#expressions">expression</a> which results to a boolean value.
The <code>Condition</code> portion can be enclosed in a pair of <code>()</code> or not,
but it can't be enclosed together with the <code>InitSimpleStatement</code> portion.
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>if-else</code> block is present,
it will be executed before executing other statements in the <code>if-else</code> block.
If the <code>InitSimpleStatement</code> is absent,
then the semicolon following it is optional.
</p>

<p>
Each <code>if-else</code> control flow forms
one implicit code block, one <code>if</code> branch explicit code block
and one optional <code>else</code> branch code block.
The two branch code blocks are both nested in the implicit code block.
Upon execution, if <code>Condition</code> expression results in <code>true</code>,
then the <code>if</code> branch block will get executed, otherwise,
the <code>else</code> branch block will get executed.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // needed before Go 1.20

	if n := rand.Int(); n%2 == 0 {
		fmt.Println(n, "is an even number.")
	} else {
		fmt.Println(n, "is an odd number.")
	}

	n := rand.Int() % 2 // this n is not the above n.
	if n % 2 == 0 {
		fmt.Println("An even number.")
	}

	if ; n % 2 != 0 {
		fmt.Println("An odd number.")
	}
}
</code></pre>

<p>
</p>

<p>
If the <code>InitSimpleStatement</code> in a <code>if-else</code> code block is a short variable declaration,
then the declared variables will be viewed as being declared in the top nesting implicit code block of the <code>if-else</code> code block.
</p>

<p>
An <code>else</code> branch code block can be implicit if the corresponding <code>else</code>
is followed by another <code>if-else</code> code block, otherwise, it must be explicit.
</p>

Example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"time"
)

func main() {
	if h := time.Now().Hour(); h < 12 {
		fmt.Println("Now is AM time.")
	} else if h > 19 {
		fmt.Println("Now is evening time.")
	} else {
		fmt.Println("Now is afternoon time.")
		h := h // the right one is declared above
		// The just new declared "h" variable
		// shadows the above same-name one.
		_ = h
	}

	// h is not visible here.
}
</code></pre>

<p>
</p>

</div>

<a class="anchor" id="for"></a>
<h3><code>for</code> Loop Control Flow Blocks</h3>

<div>
The full form of a <code>for</code> loop block is:
<pre class="line-numbers"><code class="language-go">for InitSimpleStatement; Condition; PostSimpleStatement {
	// do something
}
</code></pre>

<p>
<code>for</code> is a keyword.
The <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code> portions
must be both simple statements, and the <code>PostSimpleStatement</code> portion
must not be a short variable declaration.
<code>Condition</code> must be an expression which result is a boolean value.
The three portions are all optional.
</p>

<p>
Unlike many other programming languages, the just mentioned three parts following
the <code>for</code> keyword can't be enclosed in a pair of <code>()</code>.
</p>

<p>
Each <code>for</code> control flow forms at least two code blocks,
one is implicit and one is explicit.
The explicit one is nested in the implicit one.
</p>

<p>
The <code>InitSimpleStatement</code> in a <code>for</code> loop block
will be executed (only once) before executing other statements in the <code>for</code> loop block.
</p>

<p>
The <code>Condition</code> expression will be evaluated at each loop step.
If the evaluation result is <code>false</code>, then the loop will end.
Otherwise the body (a.k.a., the explicit code block) of the loop will get executed.
</p>

<p>
The <code>PostSimpleStatement</code> will be executed at the end of each loop step.
</p>


A <code>for</code> loop example. The example will print the integers from
<code>0</code> to <code>9</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	fmt.Println(i)
}
</code></pre>

<p>
</p>

If the <code>InitSimpleStatement</code> and <code>PostSimpleStatement</code>
portions are both absent (just view them as blank statements),
their nearby two semicolons can be omitted.
The form is called as condition-only <code>for</code> loop form.
It is the same as the <code>while</code> loop in other languages.
<pre class="line-numbers"><code class="language-go">var i = 0
for ; i < 10; {
	fmt.Println(i)
	i++
}
for i < 20 {
	fmt.Println(i)
	i++
}
</code></pre>

<p>
</p>

If the <code>Condition</code> portion is absent,
compilers will view it as <code>true</code>.
<pre class="line-numbers"><code class="language-go">for i := 0; ; i++ { // <=> for i := 0; true; i++ {
	if i >= 10 {
		// "break" statement will be explained below.
		break
	}
	fmt.Println(i)
}

// The following 4 endless loops are
// equivalent to each other.
for ; true; {
}
for true {
}
for ; ; {
}
for {
}
</code></pre>

<p>
</p>

If the <code>InitSimpleStatement</code> in a <code>for</code> block is a short variable declaration statement,
then the declared variables will be viewed as being declared in the top nesting implicit code block of the <code>for</code> block.
For example, the following code snippet prints <code>012</code> instead of <code>0</code>.

<pre class="line-numbers"><code class="language-go">for i := 0; i < 3; i++ {
	fmt.Print(i)
	// The left i is a new declared variable,
	// and the right i is the loop variable.
	i := i
	// The new declared variable is modified, but
	// the old one (the loop variable) is not yet.
	i = 10
	_ = i
}
</code></pre>

<p>
</p>

A <code>break</code> statement can be used to make execution jump out of the
<code>for</code> loop control flow block in advance,
if the <code>for</code> loop control flow block is the innermost breakable
control flow block containing the <code>break</code> statement.

<pre class="line-numbers"><code class="language-go">i := 0
for {
	if i >= 10 {
		break
	}
	fmt.Println(i)
	i++
}
</code></pre>

<p>
</p>

A <code>continue</code> statement can be used to end the current loop step
in advance (<code>PostSimpleStatement</code> will still get executed),
if the <code>for</code> loop control flow block is the innermost
loop control flow block containing the <code>continue</code> statement.
For example, the following code snippet will print <code>13579</code>.

<pre class="line-numbers"><code class="language-go">for i := 0; i < 10; i++ {
	if i % 2 == 0 {
		continue
	}
	fmt.Print(i)
}
</code></pre>

</div>

<a class="anchor" id="switch-case"></a>
<h3><code>switch-case</code> Control Flow Blocks</h3>

<div>

<p>
<code>switch-case</code> control flow block is
one kind of conditional execution control flow blocks.
</p>

The full form a <code>switch-case</code> block is
<pre class="line-numbers"><code class="language-go">switch InitSimpleStatement; CompareOperand0 {
case CompareOperandList1:
	// do something
case CompareOperandList2:
	// do something
...
case CompareOperandListN:
	// do something
default:
	// do something
}
</code></pre>

In the full form,
<ul>
<li>
	<code>switch</code>, <code>case</code> and <code>default</code> are three keywords.
</li>
<li>
	The <code>InitSimpleStatement</code> portion must be a simple statement.
	The <code>CompareOperand0</code> portion is an expression which is viewed as
	a typed value (if it is an untyped value,
	then it is viewed as a type value of its default type),
	hence it can't be an untyped <code>nil</code>.
	<code>CompareOperand0</code> is called as switch expression in Go specification.
</li>
<li>
	Each of the <code>CompareOperandListX</code>
	(<code>X</code> may represent from <code>1</code> to <code>N</code>)
	portions must be a comma separated expression list.
	Each of these expressions shall be comparable with <code>CompareOperand0</code>.
	Each of these expressions is called as a case expression in Go specification.
	If a case expression is an untyped value,
	then it must be implicitly convertible to the type of the switch expression
	in the same <code>switch-case</code> control flow.
	If the conversion is impossible to achieve, compilation fails.
</li>
</ul>

<p>
Each <code>case CompareOperandListX:</code> or <code>default:</code>
opens (and is followed by) an implicit code block.
The implicit code block and that <code>case CompareOperandListX:</code> or <code>default:</code> forms a branch.
Each such branch is optional to be present.
We call an implicit code block in such a branch as a branch code block later.
</p>

<p>
There can be at most one <code>default</code> branch
in a <code>switch-case</code> control flow block.
</p>

<p>
Besides the branch code blocks,
each <code>switch-case</code> control flow forms two code blocks,
one is implicit and one is explicit.
The explicit one is nested in the implicit one.
All the branch code blocks are nested in the explicit one
(and nested in the implicit one indirectly).
</p>

<p>
<code>switch-case</code> control flow blocks are breakable,
so <code>break</code> statements can also be used in any branch code block
in a <code>switch-case</code> control flow block to make execution jump out of
the <code>switch-case</code> control flow block in advance.
</p>



<p>
The <code>InitSimpleStatement</code> in a <code>for</code> loop block
will be executed (only once) before executing other statements in the <code>for</code> loop block.
</p>

<p>
The <code>InitSimpleStatement</code> will get executed firstly
when a <code>switch-case</code> control flow gets executed,
then the switch <code>CompareOperand0</code> expression will be evaluated and only evaluated once.
The evaluation result is always a typed value.
The evaluation result will be compared (by using the <code>==</code> operator)
with the evaluation result of each case expression in the
<code>CompareOperandListX</code> expression lists,
from top to down and from left to right.
If a case expression is found to be equal to <code>CompareOperand0</code>,
the comparison process stops and the corresponding branch code block
of the expression will be executed.
If none case expressions are found to be equal to <code>CompareOperand0</code>,
the default branch code block (if it is present) will get executed.
</p>

A <code>switch-case</code> control flow example:
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // needed before Go 1.20
	switch n := rand.Intn(100); n%9 {
	case 0:
		fmt.Println(n, "is a multiple of 9.")

		// Different from many other languages,
		// in Go, the execution will automatically
		// jumps out of the switch-case block at
		// the end of each branch block.
		// No "break" statement is needed here.
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1, 2 or 3.")
		// Here, this "break" statement is nonsense.
		break
	case 4, 5, 6:
		fmt.Println(n, "mod 9 is 4, 5 or 6.")
	// case 6, 7, 8:
		// The above case line might fail to compile,
		// for 6 is duplicate with the 6 in the last
		// case. The behavior is compiler dependent.
	default:
		fmt.Println(n, "mod 9 is 7 or 8.")
	}
}
</code></pre>

<p>
The <code>rand.Intn</code> function returns a non-negative <code>int</code>
random value which is smaller than the specified argument.
</p>

<!--
https://github.com/golang/go/issues/28357
https://github.com/golang/go/blob/5a7cfbc0117bce314c3f079ece459173b9efc854/src/cmd/compile/internal/gc/swt.go#L637
-->
<p>
Note, if any two case expressions in a <code>switch-case</code> control flow
can be detected to be equal at compile time, then a compiler may reject the latter one.
For example, the standard Go compiler thinks the <code>case 6, 7, 8</code> line
in the above example is invalid if that line is not commented out.
But other compilers may think that line is okay.
In fact, the current standard Go compiler (version 1.20)
<a href="https://github.com/golang/go/issues/28357">allows duplicate boolean case expressions</a>,
and gccgo (v8.2) allows both duplicate boolean and string case expressions.
</p>

As the comments in the above example describes,
unlike many other languages, in Go,
at the end of each branch code block, the execution will automatically
break out of the corresponding <code>switch-case</code> control block.
Then how to let the execution slip into the next branch code block?
Go provides a <code>fallthrough</code> keyword to do this task.
For example, in the following example, every branch code block
will get executed, by their orders, from top to down.

<pre class="line-numbers"><code class="language-go">rand.Seed(time.Now().UnixNano()) // needed before Go 1.20
switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	// The "fallthrough" statement makes the
	// execution slip into the next branch.
	fallthrough
case 5, 6, 7, 8:
	// A new declared variable also called "n",
	// it is only visible in the current
	// branch code block.
	n := 99
	fmt.Println("n =", n) // 99
	fallthrough
default:
	// This "n" is the switch expression "n".
	fmt.Println("n =", n)
}
</code></pre>


<p>
</p>

Please note,
<ul>
<li>
	a <code>fallthrough</code> statement must be the final statement in a branch.
</li>
<li>
	a <code>fallthrough</code> statement can't show up
	in the final branch in a <code>switch-case</code> control flow block.
</li>
</ul>

For example, the following <code>fallthrough</code> uses are all illegal.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(100) % 5; n {
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	// The if-block, not the fallthrough statement,
	// is the final statement in this branch.
	if true {
		fallthrough // error: not the final statement
	}
case 5, 6, 7, 8:
	n := 99
	fallthrough // error: not the final statement
	_ = n
default:
	fmt.Println(n)
	fallthrough // error: show up in the final branch
}
</code></pre>

<p>
</p>

<p>
The <code>InitSimpleStatement</code> and <code>CompareOperand0</code> portions
in a <code>switch-case</code> control flow are both optional.
If the <code>CompareOperand0</code> portion is absent,
it will be viewed as <code>true</code>,
a typed value of the built-in type <code>bool</code>.
If the <code>InitSimpleStatement</code> portion is absent,
the semicolon following it can be omitted.
</p>

And as above has mentioned, all branches are optional.
So the following code blocks are all legal, all of them can be viewed as no-ops.

<pre class="line-numbers"><code class="language-go">switch n := 5; n {
}

switch 5 {
}

switch _ = 5; {
}

switch {
}
</code></pre>

<p>
</p>

For the latter two <code>switch-case</code> control flow blocks in the last example,
as above has mentioned, each of the absent <code>CompareOperand0</code>
portions is viewed as a typed value <code>true</code>
of the built-in type <code>bool</code>.
So the following code snippet will print <code>hello</code>.

<pre class="line-numbers"><code class="language-go">switch { // <=> switch true {
case true: fmt.Println("hello")
default: fmt.Println("bye")
}
</code></pre>


<p>
</p>

<a class="anchor" id="default-branch-placement"></a>

Another obvious difference from many other languages is
the order of the <code>default</code> branch
in a <code>switch-case</code> control flow block can be arbitrary.
For example, the following three <code>switch-case</code> control flow blocks
are equivalent to each other.
<pre class="line-numbers"><code class="language-go">switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
default: fmt.Println("n == 2")
}

switch n := rand.Intn(3); n {
default: fmt.Println("n == 2")
case 0: fmt.Println("n == 0")
case 1: fmt.Println("n == 1")
}

switch n := rand.Intn(3); n {
case 0: fmt.Println("n == 0")
default: fmt.Println("n == 2")
case 1: fmt.Println("n == 1")
}
</code></pre>

<p>
</p>

</div>

<h3><code>goto</code> Statement and Label Declaration</h3>

<div>

<p>
Like many other languages, Go also supports <code>goto</code> statement.
A <code>goto</code> keyword must be followed by a label to form a statement.
A label is declared with the form <code>LabelName:</code>,
where <code>LabelName</code> must be an identifier.
A label which name is not the blank identifier must be used at least once.
</p>

<p>
A <code>goto</code> statement will make the execution jump to the next statement
following the declaration of the label used in the <code>goto</code> statement.
So a label declaration must be followed by one statement.
</p>

<p>
A label must be declared within a function body.
A use of a label can appear before or after the declaration of the label.
But a label is not visible (and can't appear) outside
the innermost code block the label is declared in.
</p>

The following example uses a <code>goto</code> statement and a label to implement a loop control flow.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	i := 0

Next: // here, a label is declared.
	fmt.Println(i)
	i++
	if i < 5 {
		goto Next // execution jumps
	}
}
</code></pre>

<p>
</p>

As mentioned above, a label is not visible (and can't appear)
outside the innermost code block the label is declared in.
So the following example fails to compile.

<pre class="line-numbers"><code class="language-go">package main

func main() {
goto Label1 // error
	{
		Label1:
		goto Label2 // error
	}
	{
		Label2:
	}
}
</code></pre>

<p>
</p>

<p>
Note that, if a label is declared within the scope of a variable,
then the uses of the label can't appear before the declaration of the variable.
Identifier scopes will be explained in the article
<a href="blocks-and-scopes.html">blocks and scopes in Go</a> later.
</p>

The following example also fails to compile.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func main() {
	i := 0
Next:
	if i >= 5 {
		// error: jumps over declaration of k
		goto Exit
	}

	k := i + i
	fmt.Println(k)
	i++
	goto Next

// This label is declared in the scope of k,
// but its use is outside of the scope of k.
Exit:
}
</code></pre>

<p>
The just mentioned rule <a href="https://github.com/golang/go/issues/26058">may change later</a>.
Currently, to make the above code compile okay,
we must adjust the scope of the variable <code>k</code>.
There are two ways to fix the problem in the last example.
</p>

One way is to shrink the scope of the variable <code>k</code>.
<pre class="line-numbers"><code class="language-go">func main() {
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}
	// Create an explicit code block to
	// shrink the scope of k.
	{
		k := i + i
		fmt.Println(k)
	}
	i++
	goto Next
Exit:
}
</code></pre>

The other way is to enlarge the scope of the variable <code>k</code>.
<pre class="line-numbers"><code class="language-go">func main() {
	var k int // move the declaration of k here.
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}

	k = i + i
	fmt.Println(k)
	i++
	goto Next
Exit:
}
</code></pre>

<p>
</p>

</div>

<h3><code>break</code> and <code>continue</code> Statements With Labels</h3>

<p>
A <code>goto</code> statement must contain a label.
A <code>break</code> or <code>continue</code> statement can also
contain a label, but the label is optional.
Generally, <code>break</code> containing labels are used in nested breakable control flow blocks
and <code>continue</code> statements containing labels are used in nested loop control flow blocks.
</p>

<p>
If a <code>break</code> statement contains a label,
the label must be declared just before a breakable control flow block
which contains the <code>break</code> statement.
We can view the label name as the name of the breakable control flow block.
The <code>break</code> statement will make execution jump out of
the breakable control flow block, even if the breakable control flow block
is not the innermost breakable control flow block containing
<code>break</code> statement.
</p>

<p>
If a <code>continue</code> statement contains a label,
the label must be declared just before a loop control flow block
which contains the <code>continue</code> statement.
We can view the label name as the name of the loop control flow block.
The <code>continue</code> statement will end the current loop step of
the loop control flow block in advance, even if the loop control flow block
is not the innermost loop control flow block containing
the <code>continue</code> statement.
</p>

The following is an example of using <code>break</code>
and <code>continue</code> statements with labels.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

func FindSmallestPrimeLargerThan(n int) int {
Outer:
	for n++; ; n++{
		for i := 2; ; i++ {
			switch {
			case i * i > n:
				break Outer
			case n % i == 0:
				continue Outer
			}
		}
	}
	return n
}

func main() {
	for i := 90; i < 100; i++ {
		n := FindSmallestPrimeLargerThan(i)
		fmt.Print("The smallest prime number larger than ")
		fmt.Println(i, "is", n)
	}
}
</code></pre>

<p>
</p>



<hr>

<div class="text-center"><a href="#i-control-flows.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><b class="index" id="i-control-flows.html">기본 흐름 제어</b></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><a class="index" href="blocks-and-scopes.html">코드 블록과 식별자 스코프</a></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












