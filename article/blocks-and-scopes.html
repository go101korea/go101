<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="description" content="Golang online books, articles, tools, etc.">
		<meta name="author" content="">
		<meta name="go-version" content="go1.20">
		<link rel="icon" href="/static/go101/images/101-v1.ico">
		<link rel="apple-touch-icon" sizes="152x152" href="/static/go101/images/iphone-v1.jpeg">
	
		<title>Code Blocks and Identifier Scopes -Go 101</title><link id="css-bs" href="/static/bootstrap/v4.0.3-dark/css/bootstrap.min.css" rel="stylesheet">
		<link id="css-go101" href="/static/go101/css/v991-dark.css" rel="stylesheet">
		<link id="css-prism" href="/static/prism/2020-08-03-dark/prism.css" rel="stylesheet">
		<script id="js-prism" src="/static/prism/2020-08-03-dark/prism.js"></script>


		<script src="/static/jquery/jquery.min-v1.11.2.js"></script>
		<script src="/static/go101/js/v5.js"></script>
		
		
		<style>
		div, p, ul, li, td, th {line-height: 1.55;}
		</style>

		<script>
		var theme = ""
		</script>
	</head>

	<body>
		<div class="container">

		<div class="row nav-bar-with-borders">
	<div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/"><small>Home</small></a> <span class="new-text"><sup>new!</sup></span>
	</div><div class="col-xs-6 col-sm-4 nav-item-active">
		<a href="/article/101.html"><small>Go 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/generics/101.html"><small>Go Generics 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/details-and-tips/101.html"><small>Go Details &amp; Tips 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/optimizations/101.html"><small>Go Optimizations 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/quizzes/101.html"><small>Go Quizzes 101</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go HowTo 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Practices 101</small></div>
	
	<div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;"><small>Go Agg 101</small></div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/blog/101.html"><small>Go 101 Blog</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive">
		<a href="/apps-and-libs/101.html"><small>Go 101 Apps &amp; Libs</small></a>
	</div><div class="col-xs-6 col-sm-4 nav-item-inactive" style="color: #777;" id="theme-switch"><small>테마: 다크/라이트</small></div>

</div>

<div class="alert alert-warning text-center"><small>
현재 3권의 신간들인 <a href="/optimizations/101.html">Go Optimizations 101</a>,
<a href="/details-and-tips/101.html">Go Details &amp; Tips 101</a>
과 <a href="/generics/101.html">Go Generics 101</a>이 출간되어 있습니다.
Leanpub 서점에서 <a href="https://leanpub.com/b/go-optimizations-details-generics">번들</a>을 모두 구입하시는 방법이 비용 대비 효율이 가장 좋습니다.
<p></p>
Go에 대한 많은 정보들과 Go 101 책들의 최신 소식을 얻으시려면 Go 101 트위터 계정인 <a href="https://twitter.com/go100and1">@Go100and1</a>을
팔로잉 해주세요.
</small></div>
<p>
</p>



<h1>Code Blocks and Identifier Scopes</h1>



<p>
This article will explain the code blocks and identifier scopes in Go.
</p>

<p><i>
(Please note, the definitions of code block hierarchies in this article
are a little different from the viewpoint of <code>go/*</code> standard packages.)
</i></p>

<!--
https://github.com/golang/go/issues/7429#issuecomment-282480782
-->

<a class="anchor" id="block"></a>
<h3>Code Blocks</h3>

<div>

In a Go project, there are four kinds of code blocks (also called blocks later):
<ul>
<li>the <b>universe block</b> contains all project source code.</li>
<li>each package has a <b>package block</b> containing all source code,
	excluding the package import declarations in that package.</li>
<li>each file has a <b>file block</b> containing all the source code,
	including the package import declarations, in that file.</li>
<li>generally, a pair of braces <code>{}</code> encloses a <b>local block</b>.
	However, some local blocks aren't enclosed within <code>{}</code>,
	such blocks are called implicit local blocks.
	The local blocks enclosed in <code>{}</code> are called explicit local blocks.
	The <code>{}</code> in composite literals and type definitions don't form
	local blocks.
</li>
</ul>

Some keywords in all kinds of control flows are followed by some implicit code blocks.
<ul>
<li>
	An <code>if</code>, <code>switch</code> or <code>for</code> keyword
	is followed by two nested local blocks. One is implicit, the other is explicit.
	The explicit one is nested in the implicit one.
	If such a keyword is followed by a short variable declaration,
	then the variables are declared in the implicit block.
</li>
<li>
	An <code>else</code> keyword is followed by one explicit or implicit block,
	which is nested in the implicit block following its <code>if</code> counterpart keyword.
	If the <code>else</code> keyword is followed by another <code>if</code> keyword,
	then the code block following the <code>else</code> keyword can be implicit,
	otherwise, the code block must be explicit.
</li>
<li>
	An <code>select</code> keyword is followed by one explicit block.
</li>
<li>
	Each <code>case</code> and <code>default</code> keyword is followed by one implicit block,
	which is nested in the explicit block following its corresponding
	<code>switch</code> or <code>select</code> keyword.
</li>
</ul>

<p>
The local blocks which aren't nested in any other local blocks are called top-level
(or package-level) local blocks. Top-level local blocks are all function bodies.
</p>

<p>
Note, the input parameters and output results of a function are viewed as being
declared in explicit body code block of the function, even if their declarations
stay out of the pair of braces enclosing the function body block.
</p>
</div>


<div>
Code block hierarchies:
<ul>
<li>package blocks are nested in the universe block.</li>
<li>file blocks are also directly nested in the universe block, instead of package blocks.
	(This explanation is different from the <code>go/*</code> standard packages.)
</li>
<li>each top-level local block is nested in both a package block and a file block.
	(This explanation is also different from the <code>go/*</code> standard packages.)
</li>
<li>a non-top local block must be nested in another local block.</li>
</ul>

<p><i>
(The differences to Go specification are to make the below explanations for identifier shadowing simpler.)
</i></p>

Here is a picture shows the block hierarchies in a program:
<div class="text-center">
	<img src="res/blocks.png" alt="code block hierarchies"></img>
</div>

<p>
</p>
</div>

<p>
Code blocks are mainly used to explain allowed declaration positions and scopes of source code element identifiers.
</p>

<a class="anchor" id="declaration"></a>
<h3>Source Code Element Declaration Places</h3>

<div>
There are six kinds of source code elements which can be declared:
<ul>
<li>package imports.</li>
<li>defined types and type alias.</li>
<li>named constants.</li>
<li>variables.</li>
<li>functions.</li>
<li>labels.</li>
</ul>
<p>
Labels are used in the <code>break</code>, <code>continue</code>, and <code>goto</code> statements.
</p>
</div>

<p>
A declaration binds a non-blank identifier to a source code element (constant, type, variable, function, label, or package).
In other words, in the declaration, the declared source code element is named as the non-blank identifier.
After the declaration, we can use the non-blank identifier to represent the declared source code element.
</p>



<div>
The following table shows which code blocks all kinds of source code elements can be directly declared in:
<table border="1" class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr>
	<th class="text-center" valign="bottom" align="center"></th>
	<th class="text-center" valign="bottom" align="center">the universe block</th>
	<th class="text-center" valign="bottom" align="center">package blocks</th>
	<th class="text-center" valign="bottom" align="center">file blocks</th>
	<th class="text-center" valign="bottom" align="center">local blocks</th>
	</tr>
</thead>
<tbody>
	<tr class="active">
	<th scope="row" class="text-center" valign="middle" align="center">predeclared (built-in elements) <sup>(1)</sup></th>
	<td valign="middle" align="center">Yes</td>
	<td></td>
	<td></td>
	<td></td>
	</tr>
	<tr>
	<th scope="row" class="text-center" valign="middle" align="center">package imports</th>
	<td></td>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" valign="middle" align="center">defined types and type alias (non-builtin)</th>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" valign="middle" align="center">named constants (non-builtin)</th>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" valign="middle" align="center">variables (non-builtin) <sup>(2)</sup></th>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	</tr>
	<tr>
	<th scope="row" class="text-center" valign="middle" align="center">functions (non-builtin)</th>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	<td valign="middle" align="center">Yes</td>
	<td></td>
	</tr>
	<tr class="active">
	<th scope="row" class="text-center" valign="middle" align="center">labels</th>
	<td></td>
	<td></td>
	<td></td>
	<td valign="middle" align="center">Yes</td>
	</tr>
</tbody>
</table>

<p>
<sup>(1)</sup> predeclared elements are documented in <a href="https://golang.org/pkg/builtin/"><code>builtin</code> standard package</a>.
<br/>
<sup>(2)</sup> excluding struct field variables.
</p>

So,
<ul>
<li>
package imports can never be declared in package blocks and local blocks.
</li>
<li>
functions can never be declared in local blocks.
(Anonymous functions can be enclosed in local blocks but they are not declarations.)
</li>
<li>
labels can only be declared in local blocks.
</li>
</ul>

Please note,
<ul>
<li>
	if the innermost containing blocks of two code element declarations are the same one,
	then the names (identifiers) of the two code elements can't be identical.
</li>
<li>
	the name (identifier) of a package-level code element declared in a package must not
	be identical to any package import name declared in any source file in the package
	(a.k.a., a package import name in a package must not be identical to any package-level
	code element declared in the package).
	This rule might <a href="https://github.com/golang/go/issues/7429">be relaxed later</a>.
</li>
<li>
	if the innermost containing function body blocks of two label declarations are the same one,
	then the names (identifiers) of the two labels can't be identical.
</li>
<li>
	the references of a label must be within the innermost function body block containing the declaration of the label.
</li>
<li>
	some special portions in the implicit local blocks in all kinds of control flows have special requirements.
	Generally, no code elements are allowed to be directly declared in such implicit local blocks, except some short variable declarations.
	<ul>
	<li>
		Each <code>if</code>, <code>switch</code> or <code>for</code> keyword can be closely followed by a short variable declaration.
	</li>
	<li>
		Each <code>case</code> keyword in a <code>select</code> control flow can be closely followed by a short variable declaration.
	</li>
	</ul>
</li>
</ul>

<p><i>
(BTW, the <code>go/*</code> standard packages think file code blocks can only contain package import declarations.)
</i></p>
</div>

<p>
The source code elements declared in package blocks but outside of any local blocks are called package-level source code elements.
Package-level source code elements can be named constants, variables, functions, defined types, or type aliases.
</p>

<a class="anchor" id="scope"></a>
<h3>Scopes of Declared Source Code Elements</h3>

<div>
<p>
The scope of a declared identifier means the identifiable range of the identifier (or visible range).
</p>

Without considering identifier shadowing which will be explained in the last section of the current article,
<a href="https://golang.org/ref/spec#Declarations_and_scope">the scope definitions</a> for the identifiers
of all kinds of source code elements are listed below.
<ul>
<li>
	The scope of a predeclared/built-in identifier is the universe block.
</li>
<li>
	The scope of the identifier of a package import is the file block containing the package import declaration.
</li>
<li>
	The scope of an identifier denoting a constant, type, variable, or function
	(but not method) declared at package level is the package block.
</li>
<li>
	The scope of an identifier denoting a method receiver, function parameter,
	or result variable is the corresponding function body (a local block).
</li>
<li>
	The scope of the identifier of a constant or a variable declared inside a function body
	begins at the end of the specification of the constant or variable
	(or the end of the declaration for a short declared variable)
	and ends at the end of the innermost containing block.
</li>
<li>
	The scope of the identifier of a type of type alias declared inside
	a function body begins at the end of the identifier in the corresponding
	type specification and ends at the end of the innermost containing block.
</li>
<li>
	The scope of a label is the body of the innermost function body block containing the label declaration
	but excludes all the bodies of anonymous functions nested in the containing function.
</li>
<li>
	About the scopes of type parameters, please read the
	<a href="https://go101.org/generics/555-type-constraints-and-parameters.html#type-parameter-scope">Go generics 101</a> book.
</li>
</ul>
</div>

<p>
Blank identifiers have no scopes.
</p>

<p><i>
(Note, the predeclared <code>iota</code> is only visible in constant declarations.)
</i></p>

<a class="anchor" id="scope-difference-detail"></a>
<div>
You may have noticed the minor difference of identifier scope definitions
between local type definitions and local variables, local constants and local type aliases.
The difference means a defined type may be able to
reference itself in its declaration.
Here is an example to show the difference.
<pre class="line-numbers"><code class="language-go">package main

func main() {
	// var v int = v   // error: v is undefined
	// const C int = C // error: C is undefined
	/*
	type T = struct {
		*T    // error: T uses <T>
		x []T // error: T uses <T>
	}
	*/

	// Following type definitions are all valid.
	type T struct {
		*T
		x []T
	}
	type A [5]*A
	type S []S
	type M map[int]M
	type F func(F) F
	type Ch chan Ch
	type P *P

	// ...
	var p P
	p = &p
	p = ***********************p
	***********************p = p

	var s = make(S, 3)
	s[0] = s
	s = s[0][0][0][0][0][0][0][0]

	var m = M{}
	m[1] = m
	m = m[1][1][1][1][1][1][1][1]
}
</code></pre>

<p>
Note, call <code>fmt.Print(s)</code> and call <code>fmt.Print(m)</code> both panic (for stack overflow).
</p>

And the scope difference between package-level and local declarations:
<pre class="line-numbers"><code class="language-go">package main

// Here the two identifiers at each line are the
// same one. The right ones are both not the
// predeclared identifiers. Instead, they are
// same as respective left one. So the two
// lines both fail to compile.
/*
const iota = iota // error: constant definition loop
var true = true   // error: typechecking loop
*/

var a = b // can reference variables declared later
var b = 123

func main() {
	// The identifiers at the right side in the
	// next two lines are the predeclared ones.
	const iota = iota // ok
	var true = true   // ok
	_ = true

	// The following lines fail to compile, for
	// c references a later declared variable d.
	/*
	var c = d
	var d = 123
	_ = c
	*/
}
</code></pre>
</div>

<a class="anchor" id="shadow"></a>
<h3>Identifier Shadowing</h3>

<div>
<p>
Ignoring labels, an identifier declared in an outer code block can be
shadowed by the same identifier declared in code blocks
nested (directly or indirectly) in the outer code block.
</p>

<p>
Labels can’t be shadowed.
</p>

<p>
If an identifier is shadowed, its scope will exclude the scopes of its shadowing identifiers.
</p>

Below is an interesting example.
The code contains 6 declared variables named <code>x</code>.
A <code>x</code> declared in a deeper block shadows
the <code>x</code>s declared in shallower blocks.
<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var p0, p1, p2, p3, p4, p5 *int
var x = 9999 // x#0

func main() {
	p0 = &x
	var x = 888  // x#1
	p1 = &x
	for x := 70; x < 77; x++ {  // x#2
		p2 = &x
		x := x - 70 //  // x#3
		p3 = &x
		if x := x - 3; x > 0 { // x#4
			p4 = &x
			x := -x // x#5
			p5 = &x
		}
	}

	// 9999 888 77 6 3 -3
	fmt.Println(*p0, *p1, *p2, *p3, *p4, *p5)
}
</code></pre>

<p>
</p>

Another example: the following program prints <code>Sheep Goat</code> instead of <code>Sheep Sheep</code>.
Please read the comments for explanations.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"

var f = func(b bool) {
	fmt.Print("Goat")
}

func main() {
	var f = func(b bool) {
		fmt.Print("Sheep")
		if b {
			fmt.Print(" ")
			f(!b) // The f is the package-level f.
		}
	}
	f(true) // The f is the local f.
}
</code></pre>

<p>
</p>

If we modify the above program as the following shown, then it will print <code>Sheep Sheep</code>.

<pre class="line-numbers"><code class="language-go">func main() {
	var f func(b bool)
	f = func(b bool) {
		fmt.Print("Sheep")
		if b {
			fmt.Print(" ")
			f(!b) // The f is also the local f now.
		}
	}
	f(true)
}
</code></pre>

<p>
</p>

For some circumstances, when identifiers are shadowed by variables
declared with short variable declarations,
some new gophers may get confused about whether a variable
in a short variable declaration is redeclared or newly declared.
The following example (which has bugs) shows the famous trap in Go.
Almost every gopher has ever fallen into the trap in the early days of using Go.

<pre class="line-numbers"><code class="language-go">package main

import "fmt"
import "strconv"

func parseInt(s string) (int, error) {
	n, err := strconv.Atoi(s)
	if err != nil {
		// Some new gophers may think err is an
		// already declared variable in the following
		// short variable declaration. However, both
		// b and err are new declared here actually.
		// The new declared err variable shadows the
		// err variable declared above.
		b, err := strconv.ParseBool(s)
		if err != nil {
			return 0, err
		}

		// If execution goes here, some new gophers
		// might expect a nil error will be returned.
		// But in fact, the outer non-nil error will
		// be returned instead, for the scope of the
		// inner err variable ends at the end of the
		// outer if-clause.
		if b {
			n = 1
		}
	}
	return n, err
}

func main() {
	fmt.Println(parseInt("TRUE"))
}
</code></pre>

The output:

<pre class="output"><code>1 strconv.Atoi: parsing "TRUE": invalid syntax
</code></pre>

<p>
</p>

<a class="anchor" id="weird-shadowing"></a>

Go only has <a href="keywords-and-identifiers.html#keyword">25 keywords</a>.
Keywords can't be used as identifiers.
Many familiar words in Go are not keywords, such as <code>int</code>, <code>bool</code>,
<code>string</code>, <code>len</code>, <code>cap</code>, <code>nil</code>, etc.
They are just predeclared (built-in) identifiers.
These predeclared identifiers are declared in the universe block,
so custom declared identifiers can shadow them.
Here is a weird example in which many predeclared identifiers are shadowed.
Its compiles and runs okay.
<pre class="line-numbers"><code class="language-go">package main

import (
	"fmt"
)

// Shadows the built-in function identifier "len".
const len = 3
// Shadows the built-in const identifier "true".
var true = 0
// Shadows the built-in variable identifier "nil".
type nil struct {}
// Shadows the built-in type identifier "int".
func int(){}

func main() {
	fmt.Println("a weird program")
	var output = fmt.Println

	// Shadows the package import "fmt".
	var fmt = [len]nil{{}, {}, {}}
	// Sorry, "len" is a constant.
	// var n = len(fmt)
	// Use the built-in cap function instead, :(
	var n = cap(fmt)

	// The "for" keyword is followed by one
	// implicit local code block and one explicit
	// local code block. The iteration variable
	// "true" shadows the package-level variable
	// "true" declared above.
	for true := 0; true < n; true++ {
		// Shadows the built-in const "false".
		var false = fmt[true]
		// The new declared "true" variable
		// shadows the iteration variable "true".
		var true = true+1
		// Sorry, "fmt" is an array, not a package.
		// fmt.Println(true, false)
		output(true, false)
	}
}
</code></pre>

The output:
<pre class="output"><code>a weird program
1 {}
2 {}
3 {}
</code></pre>

<p>
Yes, this example is extreme.
It contains many bad practices.
Identifier shadowing is useful, but please don't abuse it.
</p>

</div>
<hr>

<div class="text-center"><a href="#i-blocks-and-scopes.html">Index↡</a></div>



<hr>

<div id="contact" class="alert alert-success"><small>

<p>
The <b><i>Go 101</i></b> 프로젝트는 <a href="https://github.com/go101/go101">Github</a>
에서 호스팅됩니다.
오타, 문법 오류, 부정확한 표현, 설명 결함, 코드 버그, 끊어진 링크와 같은 모든
종류의 실수에 대한 수정 사항을 제출하여 Go 101을 개선을 돕는 것은 언제나 환영합니다.
</p>

<p>
주기적으로 Go에 대한 깊이 있는 정보를 얻고 싶다면 Go 101의 공식 트위터 계정인
<a href="https://twitter.com/go100and1">@go100and1</a>을 팔로우하거나
<a href="https://join.slack.com/t/go-101/shared_invite/zt-y2pvwg00-Oz7lDDJu44l~hZsFRUApiA">Go 101 슬랙 채널</a>에j가입해주세요.
</p>

</small></div>

<div class="alert alert-warning"><small>


<div id="ebooks">
이 책의 디지털 버전은 아래와 같은 곳을 통해서 구매할 수 있습니다.
<ul>
<li>
	<a href="https://leanpub.com/go101">Leanpub</a>,
	<i>최소 19.99 달러</i>.
</li>
<li>
	
	아마존 킨들 스토어, <i>(현재는 사용 불가)</i>.
</li>
<li>
	<a href="https://books.apple.com/book/id1459984231">애플 북 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://play.google.com/store/books/details?id=Dc1wEAAAQBAJ">구글 플레이 스토어</a>,
	<i>19.99 달러</i>.
</li>
<li>
	<a href="https://github.com/go101/go101/releases">무료 전자책</a>,
	pdf, epub과 azw3 포맷을 지원
</li>
</ul>
	</div>
<div>

Go 101의 저자인 Tapir는 2016년 7월부터 Go 101 시리즈 책들을 집필하고 go101.org 웹사이트를 유지 관리하고 있습니다.
새로운 콘텐츠는 책과 웹사이트에 수시로 추가될 예정입니다.
Tapir는 인디 게임 개발자이기도 합니다.
<a href="https://www.tapirgames.com">Tapir의 게임</a>을 플레이하여 Go 101을 지원할 수도 있습니다.
(안드로이드와 아이폰/아이패드용):
<ul>
<li>
	<a href="https://www.tapirgames.com/App/Color-Infection">Color Infection</a> (★★★★★), 140개 이상의 단계로 이루어진 물리 기반의 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Rectangle-Pushers">Rectangle Pushers</a> (★★★★★), 2가지 모드와 104개 이상의 단계로 이루어진 캐주얼 퍼즐 게임
</li>
<li>
	<a href="https://www.tapirgames.com/App/Let-Us-Play-With-Particles">Let's Play With Particles</a>, 세가지 미니 게임이 있는 캐주얼 액션 게임
</li>
</ul>
</div>

<a href="https://paypal.me/tapirliu">페이팔</a>을 통한 개인 기부도 환영합니다.</small></div>

<hr>
색인:


<div id="book-index">

<!-- kindle starts: 1 -->

<ul class="index part">
	<li><a class="index" href="101-about.html">Go 101에 대해</a> - 이 책이 쓰여진 이유</li>
	<li><a class="index" href="acknowledgements.html">감사의 말</a></li>
</ul>

<ul class="index part">
	<li><a class="index" href="introduction.html">Go 소개</a> - Go를 배우는 가치</li>
	<li><a class="index" href="go-toolchain.html">Go 툴체인</a> - Go 프로그램을 컴파일하고 실행하는 방법</li>
</ul>

<ul class="index part">
<li>
Go 코드에 익숙해지기

	<ul class="index chapters">
	<li><a class="index" href="basic-code-elements-introduction.html">소스 코드 요소 소개</a></li>
	<li><a class="index" href="keywords-and-identifiers.html">키워드와 식별자</a></li>
	<li><a class="index" href="basic-types-and-value-literals.html">기본 자료형과 기본 값 리터럴</a></li>
	<li><a class="index" href="constants-and-variables.html">상수와 변수</a> - 무형성(untyped) 값과 자료형 추론 소개를 포함</li>
	<li><a class="index" href="operators.html">일반 연산자</a> - 더 많은 자료형 추론 규칙 소개를 포함</li>
	<li><a class="index" href="function-declarations-and-calls.html">함수 선언과 호출</a></li>
	<li><a class="index" href="packages-and-imports.html">코드 패키지와 패키지 들여오기</a></li>
	<li><a class="index" href="expressions-and-statements.html">표현식, 구문과 단순 구문</a></li>
	<li><a class="index" href="control-flows.html">기본 흐름 제어</a></li>
	<li><a class="index" href="control-flows-more.html">고루틴, 지연된 함수 호출과 패닉/복구</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
Go 자료형 체계

	<ul class="index chapters">
	<li><a class="index" href="type-system-overview.html">Go 자료형 체계 개요</a> - Go 프로그래밍 숙달을 위해 반드시 읽어봐야 하는</li>
	<li><a class="index" href="pointer.html">포인터</a></li>
	<li><a class="index" href="struct.html">구조체</a></li>
	<li><a class="index" href="value-part.html">변수</a> - Go 변수에 대한 더 깊은 이해</li>
	<li><a class="index" href="container.html">배열, 슬라이스와 맵</a> - 1급 객체 컨테이너 자료형</li>
	<li><a class="index" href="string.html">문자열</a></li>
	<li><a class="index" href="function.html">함수</a> - 함수 자료형과 값, 가변 인자 함수</li>
	<li><a class="index" href="channel.html">채널</a> - Go에서 동시성 동기화를 하는 방법</li>
	<li><a class="index" href="method.html">메서드</a></li>
	<li><a class="index" href="interface.html">인터페이스</a> - 리플렉션과 다형성을 하는 값 상자</li>
	<li><a class="index" href="type-embedding.html">자료형 임베딩</a> - 자료형을 확장하는 방법</li>
	<li><a class="index" href="unsafe.html">자료형에 안전하지 않는 포인터</a></li>
	<li><a class="index" href="generic.html">제네릭</a> - 합성 자료형의 사용과 읽는 법</li>
	<li><a class="index" href="reflection.html">리플렉션</a> - <code>reflect</code> 표준 패키지</li>
	</ul>
</li>
</ul>

<!-- kindle ends: 1 -->

<!-- kindle starts: 2 -->

<ul class="index part">
<li>
특별 주제

	<ul class="index chapters">
	<li><a class="index" href="line-break-rules.html">개행 규칙</a></li>
	<li><a class="index" href="defer-more.html">지연된 함수 호출 더 알아보기</a></li>
	<li><a class="index" href="panic-and-recover-use-cases.html">패닉/복구 사용 사례</a></li>
	<li><a class="index" href="panic-and-recover-more.html">패닉/복구 메커니즘에 대한 고찰</a> - 함수 호출 종료 단계를 포함</li>
	<li><b class="index" id="i-blocks-and-scopes.html">코드 블록과 식별자 스코프</b></li>
	<li><a class="index" href="evaluation-orders.html">표현식 평가 순서</a></li>
	<li><a class="index" href="value-copy-cost.html">Go의 값 복사 비용</a></li>
	<li><a class="index" href="bounds-check-elimination.html">경계 검사 제거(BCE)</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
동시성 프로그래밍

	<ul class="index chapters">
	<li><a class="index" href="concurrent-synchronization-overview.html">동시성 동기화 개요</a></li>
	<li><a class="index" href="channel-use-cases.html">채널 사용 사례</a></li>
	<li><a class="index" href="channel-closing.html">채널을 깔끔하게 닫는 방법</a></li>
	<li><a class="index" href="concurrent-synchronization-more.html">기타 동시성 동기화 기술</a> - <code>sync</code> 표준 패키지</li>
	<li><a class="index" href="concurrent-atomic-operation.html">원자적 연산</a> - <code>sync/atomic</code> 표준 패키지</li>
	<li><a class="index" href="memory-model.html">Go의 메모리 순서 보장</a></li>
	<li><a class="index" href="concurrent-common-mistakes.html">흔히들 저지르는 동시성 프로그래밍 실수들</a></li>
	</ul>

</li>
</ul>


<ul class="index part">
<li>
메모리 관련

	<ul class="index chapters">
	<li><a class="index" href="memory-block.html">메모리 블록</a></li>
	<li><a class="index" href="memory-layout.html">메모리 레이아웃</a></li>
	<li><a class="index" href="memory-leaking.html">메모리 누수 시나리오</a></li>
	</ul>

</li>
</ul>

<ul class="index part">
<li>
일부 요약

	<ul class="index chapters">
	<li><a class="index" href="summaries.html">몇 가지 간단한 요약</a></li>
	<li><a class="index" href="nil.html">Go의 <code>nil</code></a></li>
	<li><a class="index" href="value-conversions-assignments-and-comparisons.html">값 변환, 할당과 비교 규칙</a></li>
	<li><a class="index" href="exceptions.html">구문/의미 예외</a></li>
	<!-- (to remove) for printing -->
	<li><a class="index" href="details.html">Go Details 101</a></li>
	<li><a class="index" href="unofficial-faq.html">Go FAQ 101</a></li>
	<li><a class="index" href="tips.html">Go Tips 101</a></li>
	<!-- (to remove) -->
	</ul>

</li>
</ul>

<!-- kindle ends: 2 -->

<!-- kindle starts: 0 -->

<ul class="index part">
<li><a class="index" href="more.html">더 많은 토픽</a></li>
</ul>

<!-- kindle ends: 0 -->

</div>








		</div>
	</body>
</html>












