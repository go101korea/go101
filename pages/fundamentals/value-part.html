<h1>변수</h1>

<p>
이 문서와 다음 문서에서는 더 많은 종류의 Go type들을 소개합니다.
이 다음 문서들을 쉽고 깊게 이해하기 위한 최선의 방법은 다음 문서들을 읽기 전에
이 문서를 먼저 읽는 것입니다.
</p>

<h3>Go Type들의 두가지 분류</h3>

<div>
<p>
Go는 <a href="pointer.html">pointers in Go</a>와 <a href="struct.html">structs in Go</a>
이 이전 두 문서들에서 본 것과 같이 C와 비슷한 언어로 여겨진다.
구조체 타입과 포인터 타입들과 같은 메모리 구조는 Go와 C에서 매우 비슷하다.
</p>

<p>
한편으로는, Go는 C언어의 프레임워크로 여겨지기도 합니다.
이 말은 C의 주요 특징으로 메모리 구조들이 투명하다는 점인 반면
Go는 변수-메모리(value-memory) 구조가 완전히 투명하지 않은 여러 종류의 type을 지원한다는 점이 반영 된 것입니다.
각 C언어의 변수들은 하나의 <a href="memory-block.html">메모리 블록</a>(하나의 연속적인 메모리 세그먼트)을 가지고 있습니다.
그러나 Go가 제공하는 type들은 하나나 그 이상의 메모리 블록을 가질 수도 있습니다.
</p>

<p>
앞으로, 변수로 이루어진 부분(다른 메모리 블록들에 분산되어 있는)들을 '변수 부분'(value-part)이라고 부르도록 하겠습니다.
변수 부분은 직접 변수 부분(direct value-part)과
직접 변수 부분이 <a href="pointer.html#references">참조</a> 되어있는 간접 변수 부분으로 이루어져 있습니다.
</p>
다음 표는 Go의 두 가지 타입들을 설명합니다:
		
<table border="1" class="table table-bordered text-center" style="width: auto !important;">
<thead>
	<tr class="active">
	<th class="text-center" valign="bottom" align="center" style="with: 50%">하나의 메모리 블록만 제공하는 타입들</th>
	<th class="text-center" valign="bottom" align="center" style="with: 50%">하나 이상의 메모리 블록들을 제공하는 타입들</th>
	</tr>
</thead>
<tbody>
	<tr>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">
			<img src="res/value-parts-single.png" alt="single value part"></img>
		</td>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">
			<img src="res/value-parts-multiple.png" alt="multiple value parts"></img>
		</td>
	</tr>
	<tr>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">

			boolean types<br/>
			numeric types<br/>
			pointer types<br/>
			unsafe pointer types<br/>
			struct types<br/>
			array types<br/>
			
		</td>
		<td style="vertical-align: middle;" class="text-center" valign="middle" align="center">

			slice types<br/>
			map types<br/>
			channel types<br/>
			function types<br/>
			interface types<br/>
			string types<br/>

		</td>
	</tr>
</tbody>
</table>

<p>
다음 Go 101 글은 위 표에 나온 타입들을 자세히 설명합니다.
이 글은 그 설명들을 좀 더 쉽게 이해할 수 있도록 준비 하는 글입니다.
</p>

Note,
<ul>
<li>
	인터페이스와 문자열 변수에 기본 부분(underlying parts)이 포함 될 수 있는지 아닌지의 여부는 컴파일러에 따라 다릅니다.
	표준 Go 컴파일러인 경우 인터페이스와 문자열 변수는 기본 부분을 포함 할 수 있습니다.
</li>
<li>
	함수 변수(functions value)가 기본 부분을 포한 하는지에 대한 여부는 증명하기가 거의 불가능하다.
	Go 101 에서는, 함수 변수들은 기본 부분을 포함 하는 것으로 간주하도록 합니다.
</li>
</ul>

<p>
두 번째 타입 유형 분류는 많은 구현 세부 정보를 캡슐화하여 Go 프로그래밍에 많은 편의를 제공합니다.
서로 다른 Go 컴파일러들은 이 타입들에 대한 세부 구현이 다릅니다.
그러나 그 타입들이 동작하는 방식은 반드시 Go 사양의 요구사항을 만족합니다.
</p>

<p>
두번째 분류에 속하는 타입들은 첫번째 분류의 타입들을 모아서 구현할 수 있기 때문에
언어의 구성에서 반드시 필요하지는 않습니다.
그러나, 일반적이거나 독특한 기능을 캡슐화 한 이 타입들을 1급 객체로 지원하므로써
Go 프로그래밍이 조금 더 즐겁고 생산성있는 경험을 제공합니다.
</p>

<p>
반면에, 두번째 분류에 캡슐화 되어 구현된 이 타입들은 그 타입들의 많은 내부 구현을 숨깁니다.
이로 인해 Go 프로그래머가 그 타입들에 대한 전체적인 구조를 볼 수 없으며,
때로는 Go를 더 잘 이해하는데에 방해물이 될 수 있습니다.
</p>

<p>
아래의 글은 Go를 사용하는 사람들에게 두번째 분류에 속한 타입들을 더 이해하기 쉽도록
내부 구조와 정의에 대한 내용을 소개합니다.
이러한 타입들의 상세한 구현은 여기서 설명하지는 않습니다.
이 글은 표준 Go 컴파일러에서 주로 구현된 내용들을 기반으로 하지만 정확히 똑같지는 않습니다.
</p>
</div>

<h3>Go의 두가지 포인터 타입들</h3>

<div>
<p>
두번째 분류에 속하는 타입들의 내부 구조에 대한 정의를 보기에 앞서,
포인터와 참조에 대해 명확한 정의를 내리고 시작합니다.
</p>

<p>
우리는 이전 글에서  <a href="pointer.html">Go 포인터</a>에 대해 배웠습니다.
해당 글에서의 포인터 타입들은 type-safe(선언된 유형과 같은지 체크를 하는) 포인터 타입입니다.
사실, Go는 <a href="unsafe.html">type-unsafe pointer types</a> 포인터 타입도 지원합니다.
<code>unsafe.Pointer</code> 타입은 <code>unsafe</code> 패키지에서 제공되며
C 언어의 <code>void*</code> 와 비슷합니다.
</p>

<p>
Go 101의 대부분의 글에서 포인터 타입을 언급 할때 특별히 명시 하지 않는 한 type-safe 포인터 타입입니다.
그러나 이 글에서 하기의 부분은 type-safe 포인터거나 type-unsafe 포인터 일 수 있습니다.
</p>

포인터는 nil 포인터가 아닌 이상 다른 변수의 주소를 가지고 있습니다.
포인터 변수는 다른 변수를 <a href="pointer.html#references">참조</a> 하거나 어떤 변수는 포인터 변수에 의해 참조된다고 할 수 있습니다
이들 변수들 또한 간접적으로 참조됩니다.
<ul>
<li>
	만약 구조체 변수 <code>a</code>가 변수<code>c</code>를 참조하는 포인터<code>b</code>를 변수로 가지고 있다면,
	구조체 변수 <code>a</code>또한 <code>c</code>의 변수을 참조한다고 말할 수 있습니다.
</li>
<li>
	만약 변수 <code>x</code>가 변수 <code>y</code>를 참조(직접적이든 간접적이든 상관없이)하고,
	변수 <code>y</code>가 변수 <code>z</code>를 참조(직접적이든 간접적이든 상관없이)한다면,
	변수 <code>x</code>가 변수 <code>z</code>를 참조(간접적으로)한다고 말할 수 있습니다.
</li>
</ul>

<p>
따라서, 구조체 타입이 포인터 타입을 변수로 가지는 것을 <b>포인터 포함 타입(pointer wrapper type)</b>라고 부르며,
간접적이든 직접적이든 포인터를 포함할 수 있는 타입들을<b>포인터 소유 타입(pointer holder type)</b>이라고 부릅니다.
포인터 타입들과 포인터 포함 타입들은 모두 포인터 소유 타입입니다.
포인터 소유 타입으로 이루어진 배열 타입 또한 포인터 소유 타입입니다.
(배열 타입에 대한 설명은 다음 글에서 다룹니다.)
</p>
</div>

<h3>(가능함) 두번째 분류에 속하는 타입들의 내부 구현</h3>
<h3>(Possible) Internal Definitions of the Types in the Second Category</h3>

<p>
두번째 분류에 속하는 변수들의 런타임 동작을 보다 더 잘 이해하기 위해서,
그 변수들이 아래와 같이 내부적으로는 첫번째 분류에 속하는 변수으로 정의 되었다고 생각하는 것은 나쁘지 않은 생각입니다.
만약 많은 Go 타입을 사용 해보지 않았다면 당장은 이 구현들을 명확하게 이해하려고 노력할 필요는 없습니다.
이 구현에 대한 개략적인 인상만 받고 가도 괜찮습니다만
대신, 나중에 Go 프로그래밍에 대해 좀 더 경험이 쌓이면 이 글을 다시 읽어주세요.
개략적인 정의를 알고 있는 것만으로도 Go 프로그래머가 다음 글들에서 나오는 타입들에 대한 설명을 이해 하는데에 충분한 도움이 됩니다.
</p>

<h4>function types, channel, map 들의 내부 정의</h4>

<!--
https://groups.google.com/forum/#!topic/golang-nuts/91phVZwiDf8
-->

<div>
function types, channel, map 들의 내부 정의는 아래와 비슷합니다.
<pre class="line-numbers"><code class="language-go">// map types
type _map *hashtableImpl

// channel types
type _channel *channelImpl

// function types
type _function *functionImpl
</code></pre>

<p>
따라서, 내부적으로 이 세 타입들은 그냥 포인터 타입입니다.
즉, 이 타입들의 직접 변수 부분은 내부적으로 포인터입니다.
각 타입들의 0이 아닌 변수들의 직접 변수 부분은 간접 기본 구현 부분(underlying implementation part)을 참조 합니다.
</p>

<p>
그런데, Go 컴파일러는 map을 구현하기 위해 hashtable을 사용합니다.
</p>

</div>

<h4>slice type의 내부 정의</h4>

<div>
slice type의 내부 정의는 아래와 비슷합니다
<pre class="line-numbers"><code class="language-go">type _slice struct {
	// 기본 원소들을 참조
	elements unsafe.Pointer
	// 원소들의 갯수와 크기
	len, cap int
}
</code></pre>

<p>
따라서, 내부적으로 slice 타입들은 포인터 포함 struct 타입(pointer wrapper struct types)입니다.
0이 아닌 각 slice 변수들은 slice 변수의 각 원소에 저장된 간접 기본 부분(indirect underlying part)을 가집니다.
<code>elements</code> 필드의 직접 변수 부분은 slice 변수의 간접 기본 부분을 참조 합니다.
</p>
</div>

<h4>string type의 내부 정의</h4>

<div>
아래의 코드는 string type의 내부 정의입니다.
<pre class="line-numbers"><code class="language-go">type _string struct {
	elements *byte // 기본 byte 참조
	len      int   // byte 수
}
</code></pre>
<p>
따라서 string type은 내부적으로 포인터 포함 struct 타입입니다.
각 string 변수는 string 변수의 byte 수를 저장하고 있는 간접 기본 부분을 가지며,
간접 부분은 string 변수의 <code>elements</code> 필드에서 참조됩니다.
</p>
</div>

<a class="anchor" id="interface-structure"></a>
<h4>Internal definition of interface types</h4>

<div>
Below is the internal definition for general interface types:
<pre class="line-numbers"><code class="language-go">type _interface struct {
	dynamicType  *_type         // the dynamic type
	dynamicValue unsafe.Pointer // the dynamic value
}
</code></pre>

<p>
Internally, interface types are also pointer wrapper struct types.
The internal definition of an interface type has two pointer fields.
Each non-zero interface value has two indirect underlying parts
which store the dynamic type and dynamic value of that interface value.
The two indirect parts are referenced by the <code>dynamicType</code>
and <code>dynamicValue</code> fields of that interface value.
</p>

In fact, for the standard Go compiler, the above definition is only used
for blank interface types.
Blank interface types are the interface types which don't specify any methods.
We can learn more about interfaces in the article
<a href="interface.html">interfaces in Go</a> later.
For non-blank interface types, the definition like the following one is used.

<pre class="line-numbers"><code class="language-go">type _interface struct {
	dynamicTypeInfo *struct {
		dynamicType *_type       // the dynamic type
		methods     []*_function // method table
	}
	dynamicValue unsafe.Pointer // the dynamic value
}
</code></pre>

<p>
The <code>methods</code> field of the <code>dynamicTypeInfo</code> field
of an interface value stores the implemented methods of the dynamic type
of the interface value for the (interface) type of the interface value.
</p>

<!--
<p>
Go runtime will create at most one dynamic type information struct for
each interface type and dynamic type pair
and store the struct value in the global zone.
For the standard Go runtime, a dynamic type information struct value
will be never garbage collected once it is created.
All <code>_type</code> values are also stored in the global zone.
In other words, the <code>_type</code> values and dynamic type information
struct values are shared by many interface values,
they don't belong to any specified interface value.
For this reason, the current article will view each interface value may
has at most one underlying value,
which is referenced by the <code>dynamicValue</code> field.
</p>
-->

</div>

<a class="anchor" id="about-value-copy"></a>
<h3>Underlying Value Parts Are Not Copied in Value Assignments</h3>

<p>
Now we have learned that the internal definitions of the types
in the second category are pointer holder (pointer or pointer wrapper) types.
Knowing this is very helpful to understand value copy behaviors in Go.
</p>

<p>
In Go, each value assignment (including parameter passing, etc) is
a shallow value copy if the involved destination and source values
have the same type (if their types are different, we can think that
the source value will be implicitly converted to the destination type
before doing that assignment).
In other words, only the direct part of the source value is copied
to the destination value in a value assignment.
If the source value has underlying value part(s),
then the direct parts of the destination and source values
will reference the same underlying value part(s),
in other words, the destination and source values will
share the same underlying value part(s).
</p>

<div class="text-center">
<img src="res/value-parts-copy.png" alt="value part copying"></img>
</div>

<p>
In fact, the above descriptions are not 100% correct in theory, for strings and interfaces.
The <a href="https://golang.org/doc/faq#pass_by_value">official Go FAQ</a> says
the underlying dynamic value part of an interface value should be copied
as well when the interface value is copied.
However, as the dynamic value of an interface value is read only,
the standard Go compiler/runtime doesn't copy the underlying
dynamic value parts in copying interface values.
This can be viewed as a compiler optimization.
The same situation is for string values and the same optimization
(made by the standard Go compiler/runtime) is made for copying string values.
So, for the standard Go compiler/runtime, the descriptions in the last section
are 100% correct, for values of any type.
</p>

<p>
Since an indirect underlying part may not belong to any value exclusively,
it doesn't contribute to the size returned by the <code>unsafe.Sizeof</code> function.
</p>

<!--
<p>
As above mentioned, Go map values are hashtables internally.
When an interface or a string value is used as a map key, its underlying part(s)
are counted in calculating its hash.
When a channel is used as a map key, its underlying part(s) are not counted
in calculating its hash.
Slice, map and function values can't be used as map keys.
</p>
-->

<a class="anchor" id="more=about-reference"></a>
<h3>About the "Reference Type" and "Reference Value" Terminologies</h3>

<div>
The word <b><i>reference</i></b> in Go world is a big mess.
It brings many confusions to Go community.
Some articles, including some <a href="https://golang.org/doc/faq#references">official ones</a>,
use <b><i>reference</i></b> as qualifiers of types and values,
or treat <b><i>reference</i></b> as the opposite of <b><i>value</i></b>.
This is strongly discouraged in Go 101.
I really don't want to dispute on this point.
Here I just list some absolutely misuses of <b><i>reference</i></b>:
<ul>
<li>
	only slice, map, channel and function types are reference types in Go.
	(If we do need the <b><i>reference type</i></b> terminology in Go,
	then we shouldn't exclude any pointer holder types from reference types).
</li>
<li>
	references are opposites of values.
	(If we do need the <b><i>reference value</i></b> terminology in Go,
	then please view reference values as special values, instead of
	opposites of values.)
</li>
<li>
	some parameters are passed by reference.
	(Sorry, all parameters are passed by copy, <b>of direct parts</b>, in Go.)
</li>
</ul>

<p>
I don't mean the <b><i>reference type</i></b> or <b><i>reference value</i></b>
terminologies are totally useless for Go,
I just think they are not very essential, and they bring many confusions in using Go.
If we do need these terminologies, I prefer to define them as pointer holders.
And, my personal opinion is it is best to limit the <b><i>reference</i></b>
word to only representing relations between values by using it as a verb or a noun, and never use it as an adjective.
This will avoid many confusions in leaning, teaching and using Go.
</p>
</div>

